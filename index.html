<!doctype html>
<html lang="pl">
<head>
  <meta charset="utf-8">
  <meta name="robots" content="noindex">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Panel Admina</title>
  <link rel="stylesheet" href="style_admin.css">
  <script src="script_config.js"></script>
</head>
<body>
  <!-- Strona bez odnośników - dostępna tylko bezpośrednim linkiem -->
  <header>
    <h1>Panel Administracyjny</h1>
    <p class="hint">Ta strona nie ma odnośników z innych stron serwisu. Dostęp bezpośrednio przez adres URL.</p>
  </header>

  <section id="admin-tools">
    <div class="note">
      <strong>Uwaga:</strong> Nie implementować zmian na stronie bez potwierdzenia uprawnień.
    </div>

    <div class="tabs">
      <button class="tab-btn tab-active" data-tab="teams">Drużyny</button>
      <button class="tab-btn" data-tab="matches">Mecze</button>
      <button class="tab-btn" data-tab="schedule">Harmonogram</button>
      <button class="tab-btn" data-tab="planner">Planer Rozgrywek</button>
    </div> <!-- .tabs -->

    <!-- Drużyny -->
    <section class="panel" id="teams-panel">
      <h2>Drużyny</h2>

      <!-- Search and Filter Controls -->
      <div class="teams-controls">
        <div class="search-container">
          <input type="text" id="team-search" placeholder="Szukaj drużyn i zawodników..." class="search-input">
          <button id="clear-search" class="clear-btn" style="display: none;">×</button>
        </div>
        
        <div class="filter-container">
          <select id="class-filter" class="filter-select">
            <option value="">Wszystkie klasy</option>
          </select>
          
          <select id="payment-filter" class="filter-select">
            <option value="">Wszystkie płatności</option>
            <option value="paid">Opłacone</option>
            <option value="unpaid">Nieopłacone</option>
          </select>
          
          <select id="players-filter" class="filter-select">
            <option value="">Wszyscy zawodnicy</option>
            <option value="has-players">Ma zawodników</option>
            <option value="no-players">Bez zawodników</option>
          </select>
        </div>
        
        <div class="results-count">
          <span id="teams-count">0 drużyn</span>
        </div>
      </div>

      <div id="teams-loading" class="loading">Ładowanie drużyn...</div>
      <div id="teams-error" class="error" style="display:none"></div>

      <div id="teams-list" class="list"></div>

      <template id="team-template">
        <div class="team">
          <div class="team-head">
            <img src="" alt="logo" class="team-logo" onerror="this.style.display='none'">
            <h3 class="team-title"></h3>
          </div>
          <div class="players">
            <ul class="players-list"></ul>
          </div>
        </div>
      </template>
    </section>

    <!-- Mecze -->
    <section class="panel" id="matches-panel">
      <h2>Mecze</h2>

      <div class="inline-form">
        <label>Dyscyplina:
          <select id="sport-type">
            <option value="football">Piłka Nożna</option>
            <option value="basketball">Koszykówka</option>
            <option value="volleyball">Siatkówka</option>
          </select>
        </label>
        <label>Rodzaj rozgrywek:
          <select id="competition-type">
            <option value="liga">Liga</option>
            <option value="puchar">Puchar</option>
            <option value="towarzyski">Towarzyski</option>
          </select>
        </label>
      </div>

      <div id="matches-list" class="list"></div>

      <template id="match-template">
        <div class="match">
          <div class="match-head">
            <strong class="match-title"></strong>
            <button class="show-protocol">Pokaż protokół</button>
          </div>
          <div class="protocol" style="display:none">
            <p><strong>Data:</strong> <span class="m-date"></span></p>
            <p><strong>Zespół A:</strong> <span class="m-teamA"></span> — <strong>Zespół B:</strong> <span class="m-teamB"></span></p>
            <p><strong>Wynik:</strong> <span class="m-score"></span></p>
            <div class="protocol-content"></div>
          </div>
        </div>
      </template>

      <!-- Team edit modal template -->
      <template id="team-edit-template">
        <div class="modal">
          <div class="modal-content">
            <h3>Edytuj drużynę</h3>
            <form class="edit-team-form">
              <label>ID drużyny: <input name="id" readonly></label>
              <label>Nazwa: <input name="name" required></label>
              <label>Klasa: <input name="classe"></label>
              <label>Ilość wpłat: <input name="wplacone" type="number" min="0"></label>
              <label>Notatki: <textarea name="notes"></textarea></label>
              <label>Logo (link): <input name="logo"></label>
              <div class="modal-actions">
                <button type="button" class="save-team">Zapisz</button>
                <button type="button" class="cancel">Anuluj</button>
              </div>
            </form>
          </div>
        </div>
      </template>

      <!-- Player edit modal template -->
      <template id="player-edit-template">
        <div class="modal">
          <div class="modal-content">
            <h3>Edytuj zawodnika</h3>
            <form class="edit-player-form">
              <label>ID zawodnika: <input name="id" readonly></label>
              <label>Drużyna: <select name="team"></select></label>
              <label>Imię: <input name="first"></label>
              <label>Nazwisko: <input name="last"></label>
              <label>Klasa: <input name="classe"></label>
              <label><input name="captain" type="checkbox"> Kapitan</label>
              <label><input name="zgoda_rodo" type="checkbox"> Zgoda RODO</label>
              <label><input name="zgoda_gra" type="checkbox"> Zgoda gra</label>
              <label><input name="wplacone" type="checkbox"> Wpłacone</label>
              <div class="modal-actions">
                <button type="button" class="save-player">Zapisz</button>
                <button type="button" class="cancel">Anuluj</button>
              </div>
            </form>
          </div>
        </div>
      </template>
      </section> 

    <!-- Harmonogram -->
    <section class="panel" id="schedule-panel" style="display: none;">
      <h2>Harmonogram Rozgrywek</h2>

      <!-- Controls for schedule management -->
      <div class="schedule-controls">
        <div class="schedule-filters">
          <select id="schedule-sport-filter" class="filter-select">
            <option value="">Wszystkie dyscypliny</option>
            <option value="football">Piłka Nożna</option>
            <option value="basketball">Koszykówka</option>
            <option value="volleyball">Siatkówka</option>
          </select>
          
          <select id="schedule-status-filter" class="filter-select">
            <option value="">Wszystkie statusy</option>
            <option value="planned">Zaplanowane</option>
            <option value="completed">Zakończone</option>
            <option value="cancelled">Odwołane</option>
          </select>
          
          <input type="date" id="schedule-date-filter" class="filter-select" placeholder="Data meczu">
        </div>
        
        <div class="schedule-actions">
          <button id="add-match-btn" class="add-match-button">+ Dodaj Mecz</button>
        </div>
      </div>

      <div id="schedule-loading" class="loading">Ładowanie harmonogramu...</div>
      <div id="schedule-error" class="error" style="display:none"></div>

      <!-- Calendar view -->
      <div id="schedule-calendar" class="schedule-calendar">
        <div class="calendar-header">
          <div class="calendar-nav-controls">
            <button id="prev-period" class="calendar-nav">&lt;</button>
            <button id="next-period" class="calendar-nav">&gt;</button>
          </div>
          <div class="calendar-title-controls">
            <h3 id="current-period">Grudzień 2025</h3>
            <div class="view-controls">
              <button id="month-view" class="view-btn active">Miesiąc</button>
              <button id="week-view" class="view-btn">Tydzień</button>
            </div>
          </div>
          <div class="calendar-actions">
            <button id="today-btn" class="today-btn">Dziś</button>
          </div>
        </div>
        
        <!-- Month view -->
        <div id="month-view-container" class="calendar-grid">
          <div class="calendar-day-headers">
            <div class="calendar-day-header">Pon</div>
            <div class="calendar-day-header">Wt</div>
            <div class="calendar-day-header">Śr</div>
            <div class="calendar-day-header">Czw</div>
            <div class="calendar-day-header">Pt</div>
            <div class="calendar-day-header">Sob</div>
            <div class="calendar-day-header">Niedz</div>
          </div>
          <div id="calendar-days" class="calendar-days"></div>
        </div>
        
        <!-- Week view -->
        <div id="week-view-container" class="week-calendar-container" style="display: none;">
          <div class="week-time-header">
            <div class="time-column-header">Godzina</div>
            <div class="day-column-header">Poniedziałek</div>
            <div class="day-column-header">Wtorek</div>
            <div class="day-column-header">Środa</div>
            <div class="day-column-header">Czwartek</div>
            <div class="day-column-header">Piątek</div>
            <div class="day-column-header">Sobota</div>
            <div class="day-column-header">Niedziela</div>
          </div>
          <div id="week-grid" class="week-grid"></div>
        </div>
      </div>

      <!-- List view -->
      <div id="schedule-list" class="schedule-list"></div>

      <!-- Match details modal -->
      <template id="match-details-template">
        <div class="modal">
          <div class="modal-content">
            <h3>Szczegóły Mecz</h3>
            <form class="match-details-form">
              <label>ID meczu: <input name="match-id" readonly></label>
              
              <div class="form-row">
                <label>Dyscyplina:
                  <select name="sport-type">
                    <option value="football">Piłka Nożna</option>
                    <option value="basketball">Koszykówka</option>
                    <option value="volleyball">Siatkówka</option>
                  </select>
                </label>
                
                <label>Rodzaj rozgrywek:
                  <select name="competition-type">
                    <option value="liga">Liga</option>
                    <option value="puchar">Puchar</option>
                    <option value="towarzyski">Towarzyski</option>
                  </select>
                </label>
              </div>
              
              <div class="form-row">
                <label>Data: <input name="match-date" type="date" required></label>
                <label>Godzina: <input name="match-time" type="time" required></label>
              </div>
              
              <div class="form-row">
                <label>Drużyna A:
                  <select name="team-a" required>
                    <option value="">Wybierz drużynę</option>
                  </select>
                </label>
                
                <label>Drużyna B:
                  <select name="team-b" required>
                    <option value="">Wybierz drużynę</option>
                  </select>
                </label>
              </div>
              
              <div class="form-row">
                <label>Miejsce: <input name="location" placeholder="Boisko, sala itp."></label>
                <label>Sędzia: <input name="referee" placeholder="Imię i nazwisko"></label>
              </div>
              
              <label>Status:
                <select name="status">
                  <option value="planned">Zaplanowany</option>
                  <option value="completed">Zakończony</option>
                  <option value="cancelled">Odwołany</option>
                </select>
              </label>
              
              <label>Wynik: <input name="result" placeholder="np. 2:1"></label>
              <label>Notatki: <textarea name="notes" rows="3"></textarea></label>
              
              <div class="modal-actions">
                <button type="button" class="save-match">Zapisz</button>
                <button type="button" class="delete-match">Usuń</button>
                <button type="button" class="cancel">Anuluj</button>
              </div>
            </form>
          </div>
        </div>
      </template>
    </section>

    <!-- Planer Rozgrywek -->
    <section class="panel" id="planner-panel" style="display: none;">
      <div class="planner-container">
        <div class="planner-left">
          <h2>Pula meczów</h2>
          <div id="unassigned-matches-list"></div>
          <div class="planner-tools">
            <div class="block-tile" draggable="true" id="block-time-tile" title="Przeciągnij, aby zablokować czas">
              <span class="block-icon">&#10060;</span> BLOKADA CZASU
            </div>
          </div>
        </div>
        <div class="planner-right">
          <div class="planner-header">
            <button id="planner-prev-day">&#8592;</button>
            <span id="planner-date-label"></span>
            <button id="planner-next-day">&#8594;</button>
            <input type="date" id="planner-date-picker" />
          </div>
          <div class="planner-grid" id="planner-grid">
            <!-- Grid generowany dynamicznie -->
          </div>
        </div>
      </div>
    </section>

    <!-- styles moved to style_admin.css -->

    <script>
      'use strict';

      /* ==================================================
         Admin page script — organized for readability
         Sections:
         - Constants
         - Helpers (CSV parsing, fetch)
         - Teams: parsing + rendering + local editing
         - Matches: parsing + rendering + protocol fetch
         - UI: tabs and initialization
         ================================================== */

      /* ---------------------- Constants ---------------------- */
      console.log('✅ admin/index.html script is loading...');
      const SPREADSHEET_ID = '12oSSKhhbpV85d_rRQ1hUZU5KTRLPOT0SqxC1sdcNXAM';
      
      // Sheet names based on database structure
      const SHEETS = {
        PLAYERS: 'players',
        TEAMS: 'teams', 
        MATCHES_FOOTBALL: 'matches_football',
        MATCHES_BASKETBALL: 'matches_basketball',
        MATCHES_VOLLEYBALL: 'matches_volleyball',
        LOG_FOOTBALL: 'log_football',
        LOG_BASKETBALL: 'log_basketball',
        LOG_VOLLEYBALL: 'log_volleyball',
        STATS_FOOTBALL: 'stats_football',
        STATS_BASKETBALL: 'stats_basketball'
      };

      // Development toggle: use embedded sample CSVs instead of fetching from Google Sheets
      const USE_SAMPLE_DATA = false; // Change to true for testing with sample data

      // Larger sample dataset for development/testing
      const SAMPLE_PLAYERS_CSV = `ID_ZAWODNIKA,ID_DRUZYNY,Imie,Nazwisko,Klasa,Kapitan,Zgoda_RODO,Zgoda_gra,Wplacone_Stan
ZAW_001,DR_01,Piotr,Andrzejak,3E,FALSE,TRUE,TRUE,TRUE
ZAW_002,DR_01,Anna,Kowalska,2A,TRUE,TRUE,TRUE,FALSE
ZAW_003,DR_02,Jan,Nowak,2A,FALSE,TRUE,TRUE,TRUE
ZAW_004,DR_02,Monika,Zajac,2A,FALSE,FALSE,TRUE,TRUE
ZAW_005,DR_03,Kamil,Kowal,1C,TRUE,TRUE,TRUE,TRUE
ZAW_006,DR_03,Ewa,Nowicka,1C,FALSE,TRUE,FALSE,FALSE
ZAW_007,DR_04,Marek,Wiśniewski,3B,TRUE,TRUE,TRUE,TRUE
ZAW_008,DR_04,Beata,Zielińska,3B,FALSE,TRUE,TRUE,TRUE
ZAW_009,DR_04,Igor,Wójcik,3B,FALSE,TRUE,TRUE,TRUE
ZAW_010,DR_05,Patryk,Szmidt,2B,TRUE,TRUE,TRUE,FALSE
ZAW_011,DR_05,Julia,Marciniak,2B,FALSE,TRUE,TRUE,FALSE
ZAW_012,DR_06,Adam,Pawlak,1A,TRUE,TRUE,TRUE,TRUE
ZAW_013,DR_06,Olga,Kubiak,1A,FALSE,TRUE,TRUE,TRUE
ZAW_014,DR_06,Bartek,Maj,1A,FALSE,FALSE,FALSE,FALSE
ZAW_015,DR_07,Tomek,Bąk,2C,TRUE,TRUE,TRUE,TRUE
ZAW_016,DR_07,Magda,Nowakowska,2C,FALSE,TRUE,TRUE,TRUE
ZAW_017,DR_08,Grzegorz,Szymański,3C,TRUE,TRUE,TRUE,TRUE
ZAW_018,DR_08,Karolina,Piotrowska,3C,FALSE,TRUE,TRUE,TRUE
ZAW_019,DR_09,Łukasz,Kaczmarek,1B,TRUE,TRUE,TRUE,TRUE
ZAW_020,DR_09,Agnieszka,Baran,1B,FALSE,TRUE,TRUE,FALSE
ZAW_021,DR_10,Robert,Nowicki,2D,TRUE,TRUE,TRUE,TRUE
ZAW_022,DR_10,Marta,Grabowska,2D,FALSE,TRUE,TRUE,TRUE
ZAW_023,DR_10,Piotr,Krawczyk,2D,FALSE,FALSE,TRUE,FALSE
ZAW_024,DR_02,Patrycja,Górecka,2A,FALSE,TRUE,TRUE,TRUE
ZAW_025,DR_01,Kuba,Leśny,3E,FALSE,TRUE,TRUE,FALSE
ZAW_026,DR_03,Marta,Sokołowska,1C,FALSE,TRUE,TRUE,FALSE
ZAW_027,DR_05,Rafał,Zawada,2B,FALSE,TRUE,TRUE,TRUE
ZAW_028,DR_08,Anna,Małecka,3C,FALSE,TRUE,TRUE,TRUE
ZAW_029,DR_04,Piotr,Żak,3B,FALSE,TRUE,FALSE,FALSE
ZAW_030,DR_09,Basia,Wilk,1B,FALSE,TRUE,TRUE,TRUE`;

      const SAMPLE_TEAMS_CSV = `ID_DRUZYNY,Nazwa,Klasa,Wplacone_ilosc,Notatki,Logo_link
DR_01,Orły,3E,3,Brak uwag,https://example.com/logo_orly.png
DR_02,Sokoły,2A,2,Potwierdzona lista,https://example.com/logo_sokoly.png
DR_03,Lwy,1C,1,Rezerwowa drużyna,
DR_04,Twardziele,3B,4,Opłacone,https://example.com/logo_twardziele.png
DR_05,Smoki,2B,0,Brak wpłat,
DR_06,Wikingowie,1A,2,Notatka: sprzęt,https://example.com/logo_wikingowie.png
DR_07,Borsuki,2C,1,,https://example.com/logo_borsuki.png
DR_08,Orliki,3C,2,,https://example.com/logo_orliki.png
DR_09,Meteory,1B,1,Nowa drużyna,
DR_10,Rekiny,2D,3,Finaliści zeszłego roku,https://example.com/logo_rekiny.png`;

      const SAMPLE_MATCHES_CSV = `id,type,data,druzyna_a,druzyna_b,wynik,time,pitch,status
m1,liga,2025-12-26,Orły,Sokoły,3:2,07:00,0,planned
m2,puchar,2025-12-26,Lwy,Twardziele,1:3,08:00,1,planned
m3,liga,2025-12-26,Smoki,Wikingowie,0:2,09:00,2,planned
m4,liga,2025-12-26,Borsuki,Orliki,2:2,10:00,0,planned
m5,towarzyski,2025-12-26,Meteory,Rekiny,1:1,11:00,1,planned
m6,liga,2025-12-27,Orły,Lwy,2:0,07:30,0,planned
m7,liga,2025-12-27,Sokoły,Rekiny,1:4,09:00,2,planned
m8,puchar,2025-12-27,Orliki,Smoki,3:0,10:30,1,planned
m9,liga,2025-12-27,Wikingowie,Borsuki,2:2,14:00,0,planned
m10,liga,2025-12-28,Lwy,Smoki,1:0,08:00,1,planned`;

      const SAMPLE_PROTOKOLY_CSV = `id,summary,details
m1,Protokół m1,Szczegóły protokołu m1...
m2,Protokół m2,Szczegóły protokołu m2...
m3,Protokół m3,Szczegóły protokołu m3...
m4,Protokół m4,Szczegóły protokołu m4...
m5,Protokół m5,Szczegóły protokołu m5...`;

      /* ---------------------- Helpers ---------------------- */
      /** Escape HTML to prevent injection */
      function escapeHtml(str) {
        return String(str || '').replace(/[&"'<>]/g, s => ({ '&': '&amp;', '"': '&quot;', "'": '&#39;', '<': '&lt;', '>': '&gt;' })[s]);
      }

      /* ---------------------- Poprawione Helpers ---------------------- */

      /** Prosty parser CSV obsługujący cudzysłowy i polskie znaki */
      function csvToArray(csvText) {
        const lines = csvText.split('\n').filter(line => line.trim().length > 0);
        return lines.map(line => {
          const values = [];
          let current = '';
          let inQuotes = false;
          for (let i = 0; i < line.length; i++) {
            const ch = line[i];
            if (ch === '"') {
              inQuotes = !inQuotes;
            } else if (ch === ',' && !inQuotes) {
              values.push(current);
              current = '';
            } else {
              current += ch;
            }
          }
          values.push(current);
          // Czyścimy cudzysłowy i białe znaki
          return values.map(val => val.trim().replace(/^"|"$/g, '').replace(/""/g, '"'));
        });
      }

      /** Zamienia CSV na tablicę obiektów (nagłówki jako klucze) */
      function csvToObjects(csvText) {
        const rows = csvToArray(csvText);
        if (!rows || rows.length === 0) return [];
        const headers = rows[0].map(h => (h || '').trim().replace(/^"|"$/g, ''));
        return rows.slice(1).map(row => {
          const obj = {};
          headers.forEach((h, i) => {
            obj[h] = (row[i] !== undefined ? String(row[i]).trim().replace(/^"|"$/g, '') : '');
          });
          return obj;
        });
      }

      /** Pobierz i odśwież listę drużyn z Google Sheets, zaktualizuj mapy i UI */
      async function fetchAndRenderTeams() {
        try {
          const csv = await fetchCsv(SHEETS.TEAMS);
          const arr = csvToArray(csv);
          const teams = parseTeams(arr);

          // Update global data structures
          window._adminTeams = teams;
          const teamsById = {};
          const teamsByName = {};
          teams.forEach(team => {
            teamsById[team.team_id] = team;
            teamsByName[team.team_name] = team;
          });
          window._adminTeamsById = teamsById;
          window._adminTeamsByName = teamsByName;

          // Re-attach players if we have them in global players list
          if (window._adminPlayers && window._adminPlayers.length) {
            window._adminPlayers.forEach(p => {
              const team = teamsById[p.team_id];
              if (team) {
                team.players = team.players || [];
                team.players.push({
                  id: p.player_id,
                  first: p.first_name,
                  last: p.last_name,
                  classe: p.class_id,
                  captain: p.is_captain,
                  zgoda_rodo: p.consents_signed,
                  zgoda_gra: p.consents_signed,
                  wplacone: p.has_paid,
                  teamId: p.team_id
                });
              }
            });
          }

          // Re-render UI
          setTeamsMap(teamsByName);
          renderTeamsFromMap();
          populateClassFilter();

          console.log(`Fetched and rendered ${teams.length} teams from Google Sheets.`);
          return teams;
        } catch (error) {
          console.warn('Failed to fetch and render teams:', error.message);
          return null;
        }
      }

      /** Pobieranie danych (UNIKANIE CORB) */
      async function fetchCsv(sheetName, range = '') {
        // Primary: gviz out:csv (zazwyczaj daje czyste CSV)
        const baseGvizUrl = `https://docs.google.com/spreadsheets/d/${SPREADSHEET_ID}/gviz/tq`;
        const gvizUrl = `${baseGvizUrl}?tqx=out:csv&sheet=${encodeURIComponent(sheetName)}${range ? '&range=' + range : ''}`;

        async function fetchAndValidate(url) {
          const res = await fetch(url, { method: 'GET', mode: 'cors' });
          if (!res.ok) throw new Error(`Błąd HTTP: ${res.status}`);

          const contentType = (res.headers.get('content-type') || '').toLowerCase();
          const text = await res.text();

          // Jeśli otrzymaliśmy HTML (np. strona logowania) albo nagłówek wskazuje na HTML — odrzucamy
          if (contentType.includes('text/html') || text.toLowerCase().includes('<!doctype html') || text.toLowerCase().includes('<html')) {
            throw new Error('Otrzymano odpowiedź HTML (prawdopodobnie strona logowania). Upewnij się, że arkusz jest publiczny.');
          }

          return text;
        }

        try {
          try {
            return await fetchAndValidate(gvizUrl);
          } catch (primaryErr) {
            console.warn(`Primary CSV fetch failed for sheet ${sheetName}: ${primaryErr.message}`);

            // Fallback: użyj export CSV endpoint (czasem ma inny nagłówek)
            const exportUrl = `https://docs.google.com/spreadsheets/d/${SPREADSHEET_ID}/export?format=csv&sheet=${encodeURIComponent(sheetName)}${range ? '&range=' + range : ''}`;

            try {
              return await fetchAndValidate(exportUrl);
            } catch (fallbackErr) {
              console.warn(`Fallback export CSV failed for sheet ${sheetName}: ${fallbackErr.message}`);
              throw new Error(`Nie udało się pobrać CSV dla arkusza ${sheetName}. Pierwsza próba: ${primaryErr.message}. Fallback: ${fallbackErr.message}`);
            }
          }
        } catch (error) {
          console.error(`Błąd fetch (${sheetName}):`, error.message);
          throw error;
        }
      }

      /** Convert Google Visualization table to CSV format */
      function convertTableToCsv(table) {
        const rows = [];
        
        // Add header row
        const headers = table.cols.map(col => col.label || '');
        rows.push(headers);
        
        // Add data rows
        table.rows.forEach(row => {
          const values = row.c.map(cell => {
            if (cell === null) return '';
            if (typeof cell.v === 'string') {
              // Escape quotes in strings
              return `"${cell.v.replace(/"/g, '""')}"`;
            }
            return cell.v !== null ? cell.v : '';
          });
          rows.push(values);
        });
        
        // Convert to CSV string
        return rows.map(row => row.join(',')).join('\n');
      }

      /**
       * Diagnostic function to test Google Sheets connectivity
       * Run this in browser console: window.diagnoseSheetsAccess()
       */
      window.diagnoseSheetsAccess = async function() {
        console.log('%c=== Google Sheets Connectivity Diagnosis ===', 'color: blue; font-weight: bold; font-size: 14px');
        console.log(`Spreadsheet ID: ${SPREADSHEET_ID}`);
        
        const sheetsToTest = ['matches_football', 'teams', 'players'];
        
        for (const sheetName of sheetsToTest) {
          console.log(`\n%cTesting sheet: ${sheetName}`, 'color: orange; font-weight: bold');
          
          const gvizUrl = `https://docs.google.com/spreadsheets/d/${SPREADSHEET_ID}/gviz/tq?tqx=out:csv&sheet=${sheetName}`;
          console.log(`URL: ${gvizUrl}`);
          
          try {
            console.log(`Fetching...`);
            const res = await fetch(gvizUrl, {
              method: 'GET',
              credentials: 'omit',
              mode: 'cors'
            });
            
            console.log(`Status: ${res.status} ${res.statusText}`);
            console.log(`Content-Type: ${res.headers.get('content-type')}`);
            
            if (res.ok) {
              const text = await res.text();
              console.log(`✅ SUCCESS - Fetched ${text.length} bytes`);
              console.log(`First 300 chars:\n${text.substring(0, 300)}`);
            } else {
              console.log(`❌ HTTP Error ${res.status}`);
            }
          } catch (error) {
            console.log(`❌ FAILED: ${error.message}`);
            
            if (error.message.includes('Failed to fetch')) {
              console.log(`This is likely a CORS error. The spreadsheet may not be publicly shared.`);
            }
          }
        }
        
        console.log(`\n%cDiagnosis complete. Check Network tab (F12 → Network) for blocked requests.`, 'color: green; font-weight: bold');
      }

      // Global callback function for JSONP requests
      window.handleScriptResponse = function(result) {
        console.log('JSONP response received:', result);
        console.log('Response type:', typeof result);
        console.log('Response keys:', result ? Object.keys(result) : 'null');
        
        if (result && result.success) {
          showNotification(`Dane zostały zapisane (${result.rowsUpdated || 0} wierszy)`, 'success');
          // Trigger success callback if exists
          if (window._currentJsonpResolve) {
            window._currentJsonpResolve(true);
            window._currentJsonpResolve = null;
          }
          // Trigger match update callback if exists
          if (window._matchUpdateResolve) {
            window._matchUpdateResolve(true);
            window._matchUpdateResolve = null;
          }
        } else {
          const errorMsg = result ? (result.error || 'Unknown script error') : 'No response received';
          console.error('Script error:', errorMsg);
          const error = new Error(errorMsg);
          if (window._currentJsonpReject) {
            window._currentJsonpReject(error);
            window._currentJsonpReject = null;
          }
        }
      };

      /** Wywołanie API Google Apps Script przez JSONP (Bypass CORS dla zapisu) */
      async function callGoogleAppsScriptAPI(action, params) {
        return new Promise((resolve, reject) => {
          const callbackName = `jsonp_cb_${Date.now()}_${Math.round(Math.random() * 10000)}`;
          
          // Tworzymy URL z parametrami
          const urlParams = new URLSearchParams();
          urlParams.append('action', action);
          urlParams.append('callback', callbackName);
          
          for (const key in params) {
            const val = params[key];
            urlParams.append(key, typeof val === 'object' ? JSON.stringify(val) : val);
          }

          const script = document.createElement('script');
          script.src = `${GOOGLE_SCRIPT_URL}?${urlParams.toString()}`;

          // Obsługa sukcesu
          window[callbackName] = (data) => {
            cleanup();
            if (data && data.success) resolve(data);
            else reject(new Error(data ? data.error : 'Nieznany błąd API'));
          };

          // Obsługa błędu sieci/timeout
          const timeout = setTimeout(() => {
            cleanup();
            reject(new Error('Przekroczono czas oczekiwania na odpowiedź serwera (GAS)'));
          }, 20000);

          function cleanup() {
            clearTimeout(timeout);
            if (script.parentNode) script.parentNode.removeChild(script);
            delete window[callbackName];
          }

          script.onerror = () => {
            cleanup();
            reject(new Error('Błąd ładowania skryptu API. Sprawdź czy URL skryptu jest poprawny.'));
          };

          document.head.appendChild(script);
        });
      }

      /** Write data to Google Sheets using Google Apps Script */
      async function updateSheet(sheetName, data) {
        try {
          const spreadsheetId = SPREADSHEET_ID;
          
          // Determine appropriate range based on sheet type
          let range;
          switch (sheetName) {
            case SHEETS.PLAYERS:
              range = `${sheetName}!A1:I${data.length}`; // 9 columns (A-I)
              break;
            case SHEETS.TEAMS:
              range = `${sheetName}!A1:F${data.length}`; // 6 columns (A-F)
              break;
            default:
              range = `${sheetName}!A1:Z${data.length}`; // Default to 26 columns
          }
          
          // Convert data to proper format
          const values = data.map(row => 
            row.map(cell => cell === null || cell === undefined ? '' : String(cell))
          );
          
          const result = await callGoogleAppsScriptAPI('updateRange', {
            spreadsheetId: spreadsheetId,
            range: range,
            values: values
          });
          
          if (!result.success) {
            throw new Error(result.error || 'Update failed');
          }
          
          return result;
        } catch (error) {
          console.error('Error updating sheet:', error);
          showNotification('Błąd przy zapisywaniu danych: ' + error.message, 'error');
          throw error;
        }
      }

      /** Generate new unique team ID */
      function generateNewTeamId() {
        const allTeams = window._adminData?.teams || [];
        const existingIds = allTeams.map(t => parseInt(t.team_id)).filter(id => !isNaN(id));
        const maxId = existingIds.length > 0 ? Math.max(...existingIds) : 0;
        return String(maxId + 1);
      }

      /** Open modal for adding new team */
      function openAddTeamModal() {
        const tpl = document.getElementById('team-edit-template');
        const node = tpl.content.cloneNode(true);
        const modal = node.querySelector('.modal');
        const form = node.querySelector('.edit-team-form');
        
        // Change modal title for adding
        const title = modal.querySelector('h2');
        if (title) title.textContent = 'Dodaj nową drużynę';

        // Generate new team ID
        const newTeamId = generateNewTeamId();
        
        // Clear form for new team
        form.id.value = newTeamId;
        form.name.value = '';
        form.classe.value = '';
        form.wplacone.value = '';
        form.notes.value = '';
        form.logo.value = '';

        // Change save button text
        const saveBtn = form.querySelector('.save-team');
        if (saveBtn) saveBtn.textContent = 'Dodaj drużynę';

        form.querySelector('.cancel').addEventListener('click', () => modal.remove());
        form.querySelector('.save-team').addEventListener('click', async () => {
          // Validate form
          if (!form.name.value.trim()) {
            showNotification('Nazwa drużyny jest wymagana', 'error');
            return;
          }
          if (!form.classe.value.trim()) {
            showNotification('Klasa jest wymagana', 'error');
            return;
          }
          
          // Create new team object
          const newTeam = {
            id: newTeamId,
            team_id: newTeamId,
            name: form.name.value.trim(),
            team_name: form.name.value.trim(),
            classe: form.classe.value.trim(),
            class_id: form.classe.value.trim(),
            wplacone_ilosc: form.wplacone.value,
            payment_status: form.wplacone.value,
            notes: form.notes.value.trim(),
            logo: form.logo.value.trim(),
            logo_url: form.logo.value.trim(),
            players: []
          };

          // Add team to local data
          window._adminTeamsById[newTeamId] = newTeam;
          window._adminTeamsByName[newTeam.team_name] = newTeam;
          
          if (window._adminData && window._adminData.teams) {
            window._adminData.teams.push(newTeam);
          }

          // Save to Google Sheets (append new row)
          try {
            const success = await appendTeamToSheet(newTeam);
            if (success) {
              showNotification('Drużyna dodana pomyślnie', 'success');
              
              // Rebuild name map and re-render
              const nameMap = {};
              Object.values(window._adminTeamsById).forEach(t => { nameMap[t.team_name || t.name] = t; });
              setTeamsMap(nameMap);
              renderTeamsFromMap();
              modal.remove();
            } else {
              showNotification('Błąd podczas dodawania drużyny', 'error');
            }
          } catch (error) {
            console.error('Error adding team:', error);
            showNotification('Błąd podczas dodawania drużyny', 'error');
          }
        });

        document.body.appendChild(node);
      }

      /** Append new team to Google Sheets */
      async function appendTeamToSheet(team) {
        try {
          const spreadsheetId = SPREADSHEET_ID;
          
          const values = [
            [
              team.team_id,
              team.team_name,
              team.class_id,
              team.logo_url,
              team.payment_status,
              team.notes
            ]
          ];
          
          const result = await callGoogleAppsScriptAPI('appendRow', {
            spreadsheetId: spreadsheetId,
            sheetName: SHEETS.TEAMS,
            values: values
          });
          
          if (!result.success) {
            throw new Error(result.error || 'Append failed');
          }
          
          showNotification('Drużyna dodana pomyślnie', 'success');
          return result;
        } catch (error) {
          console.error('Error appending team:', error);
          showNotification('Błąd przy dodawaniu drużyny: ' + error.message, 'error');
          throw error;
        }
      }

      /** Generate new unique player ID */
      function generateNewPlayerId() {
        const allPlayers = window._adminData?.players || [];
        const existingIds = allPlayers.map(p => parseInt(p.player_id)).filter(id => !isNaN(id));
        const maxId = existingIds.length > 0 ? Math.max(...existingIds) : 0;
        return String(maxId + 1);
      }

      /** Open modal for adding new player */
      function openAddPlayerModal(teamId, team) {
        const tpl = document.getElementById('player-edit-template');
        const node = tpl.content.cloneNode(true);
        const modal = node.querySelector('.modal');
        const form = node.querySelector('.edit-player-form');
        
        // Change modal title for adding
        const title = modal.querySelector('h2');
        if (title) title.textContent = 'Dodaj nowego zawodnika';

        // Generate new player ID
        const newPlayerId = generateNewPlayerId();
        
        // Fill team selector
        const sel = form.team;
        sel.innerHTML = '';
        console.log('Available teams for selector:', Object.values(window._adminTeamsById));
        
        Object.values(window._adminTeamsById).forEach(t => {
          const opt = document.createElement('option');
          opt.value = t.team_id || t.id;
          opt.textContent = t.team_name || t.name;
          if ((t.team_id || t.id) === teamId) opt.selected = true;
          sel.appendChild(opt);
        });
        
        console.log('Team selector options:', sel.innerHTML);

        // Clear form for new player
        form.id.value = newPlayerId;
        form.first.value = '';
        form.last.value = '';
        form.classe.value = team.class_id || team.classe || '';
        form.captain.checked = false;
        form.zgoda_rodo.checked = false;
        form.zgoda_gra.checked = false;
        form.wplacone.checked = false;

        // Change save button text
        const saveBtn = form.querySelector('.save-player');
        if (saveBtn) saveBtn.textContent = 'Dodaj zawodnika';

        form.querySelector('.cancel').addEventListener('click', () => modal.remove());
        form.querySelector('.save-player').addEventListener('click', async () => {
          const newTeamId = form.team.value;
          
          // Validate form
          if (!form.first.value.trim()) {
            showNotification('Imię jest wymagane', 'error');
            return;
          }
          if (!form.last.value.trim()) {
            showNotification('Nazwisko jest wymagane', 'error');
            return;
          }
          
          // Create new player object
          const newPlayer = {
            id: newPlayerId,
            player_id: newPlayerId,
            first: form.first.value.trim(),
            last: form.last.value.trim(),
            first_name: form.first.value.trim(),
            last_name: form.last.value.trim(),
            classe: form.classe.value.trim(),
            class_id: form.classe.value.trim(),
            captain: !!form.captain.checked,
            is_captain: !!form.captain.checked,
            zgoda_rodo: !!form.zgoda_rodo.checked,
            zgoda_gra: !!form.zgoda_gra.checked,
            consents_signed: !!form.zgoda_rodo.checked && !!form.zgoda_gra.checked,
            wplacone: !!form.wplacone.checked,
            has_paid: !!form.wplacone.checked,
            teamId: newTeamId,
            team_id: newTeamId
          };

          // Add player to local team
          const targetTeam = window._adminTeamsById[newTeamId];
          if (targetTeam) {
            targetTeam.players = targetTeam.players || [];
            targetTeam.players.push(newPlayer);
          }

          // Add player to global data
          if (window._adminData && window._adminData.players) {
            window._adminData.players.push(newPlayer);
          }

          // Save to Google Sheets (append new row)
          try {
            const success = await appendPlayerToSheet(newPlayer);
            if (success) {
              showNotification('Zawodnik dodany pomyślnie', 'success');
              
              // Rebuild name map and re-render
              const nameMap = {};
              Object.values(window._adminTeamsById).forEach(t => { nameMap[t.team_name || t.name] = t; });
              setTeamsMap(nameMap);
              renderTeamsFromMap();
              modal.remove();
            } else {
              showNotification('Błąd podczas dodawania zawodnika', 'error');
            }
          } catch (error) {
            console.error('Error adding player:', error);
            showNotification('Błąd podczas dodawania zawodnika', 'error');
          }
        });

        document.body.appendChild(node);
      }

      /** Append new player to Google Sheets */
      async function appendPlayerToSheet(player) {
        try {
          const spreadsheetId = SPREADSHEET_ID;
          
          const values = [
            [
              player.player_id,
              player.first_name,
              player.last_name,
              player.class_id,
              player.is_captain ? 'TRUE' : 'FALSE',
              player.has_paid ? 'TRUE' : 'FALSE',
              player.consents_signed ? 'TRUE' : 'FALSE',
              '', // notes
              player.team_id
            ]
          ];
          
          const result = await callGoogleAppsScriptAPI('appendRow', {
            spreadsheetId: spreadsheetId,
            sheetName: SHEETS.PLAYERS,
            values: values
          });
          
          if (!result.success) {
            throw new Error(result.error || 'Append failed');
          }
          
          showNotification('Zawodnik dodany pomyślnie', 'success');
          return result;
        } catch (error) {
          console.error('Error appending player:', error);
          showNotification('Błąd przy dodawaniu zawodnika: ' + error.message, 'error');
          throw error;
        }
      }

      /** Find player row number in Google Sheets */
      function findPlayerRow(playerId) {
        // Get all players data from global storage
        const teamsById = window._adminTeamsById || {};
        
        // Search through all teams to find the player
        for (const team of Object.values(teamsById)) {
          if (team.players) {
            const playerIndex = team.players.findIndex(p => String(p.id) === String(playerId));
            if (playerIndex !== -1) {
              // Row number = header row (1) + player index in data + 1
              // If we have the original data structure, we can find the exact row
              return playerIndex + 2; // +1 for header, +1 for 1-based indexing
            }
          }
        }
        
        // Fallback: try to find in the original CSV data structure
        const allPlayers = window._adminData?.players || [];
        const playerIndex = allPlayers.findIndex(p => String(p.player_id) === String(playerId));
        if (playerIndex !== -1) {
          return playerIndex + 2; // +1 for header row
        }
        
        console.warn('Player row not found for ID:', playerId);
        return null;
      }

      /** Fetch fresh data for a specific player from Google Sheets */
      async function fetchFreshPlayerData(playerId) {
        try {
          console.log('Fetching fresh data for player:', playerId);
          
          // Fetch current players data from Google Sheets
          const playersCsv = await fetchCsv(SHEETS.PLAYERS);
          const playersArray = csvToArray(playersCsv);
          const freshPlayers = parsePlayers(playersArray);
          
          // Find the specific player
          const freshPlayer = freshPlayers.find(p => String(p.player_id) === String(playerId));
          
          if (freshPlayer) {
            console.log('Fresh player data found:', freshPlayer);
            
            // Update global data with fresh data
            if (window._adminData && window._adminData.players) {
              const index = window._adminData.players.findIndex(p => String(p.player_id) === String(playerId));
              if (index !== -1) {
                window._adminData.players[index] = { ...window._adminData.players[index], ...freshPlayer };
              }
            }
            
            return freshPlayer;
          } else {
            console.warn('Player not found in fresh data:', playerId);
            return null;
          }
        } catch (error) {
          console.error('Error fetching fresh player data:', error);
          return null;
        }
      }

      /** Fetch fresh data for a specific team from Google Sheets */
      async function fetchFreshTeamData(teamId) {
        try {
          console.log('Fetching fresh data for team:', teamId);
          
          // Fetch current teams data from Google Sheets
          const teamsCsv = await fetchCsv(SHEETS.TEAMS);
          const teamsArray = csvToArray(teamsCsv);
          const freshTeams = parseTeams(teamsArray);
          
          // Find the specific team
          const freshTeam = freshTeams.find(t => String(t.team_id) === String(teamId));
          
          if (freshTeam) {
            console.log('Fresh team data found:', freshTeam);
            
            // Update global data with fresh data
            if (window._adminTeamsById) {
              window._adminTeamsById[teamId] = { ...window._adminTeamsById[teamId], ...freshTeam };
            }
            if (window._adminData && window._adminData.teams) {
              const index = window._adminData.teams.findIndex(t => String(t.team_id) === String(teamId));
              if (index !== -1) {
                window._adminData.teams[index] = { ...window._adminData.teams[index], ...freshTeam };
              }
            }
            
            return freshTeam;
          } else {
            console.warn('Team not found in fresh data:', teamId);
            return null;
          }
        } catch (error) {
          console.error('Error fetching fresh team data:', error);
          return null;
        }
      }

      /** Find team row number in Google Sheets */
      function findTeamRow(teamId) {
        // Try to find in the original CSV data structure first
        const allTeams = window._adminData?.teams || [];
        const teamIndex = allTeams.findIndex(t => String(t.team_id) === String(teamId));
        if (teamIndex !== -1) {
          return teamIndex + 2; // +1 for header row
        }
        
        // Fallback: search through teamsById
        const teamsById = window._adminTeamsById || {};
        const allTeamsArray = Object.values(teamsById);
        const fallbackIndex = allTeamsArray.findIndex(t => String(t.team_id) === String(teamId));
        if (fallbackIndex !== -1) {
          return fallbackIndex + 2;
        }
        
        console.warn('Team row not found for ID:', teamId);
        return null;
      }

      /** Update single cell in Google Sheets */
      async function updateSingleCell(sheetName, cellAddress, value) {
        try {
          const spreadsheetId = SPREADSHEET_ID;
          const range = `${sheetName}!${cellAddress}`;
          
          const result = await callGoogleAppsScriptAPI('updateCell', {
            spreadsheetId: spreadsheetId,
            range: range,
            value: value
          });
          
          if (!result.success) {
            throw new Error(result.error || 'Update failed');
          }
          
          return result;
        } catch (error) {
          console.error('Error updating single cell:', error);
          throw error;
        }
      }
      
      /** Fallback method: Download CSV file */
      async function downloadCsvFallback(sheetName, data) {
        try {
          const csvContent = data.map(row => 
            row.map(cell => {
              const cellStr = String(cell || '');
              if (cellStr.includes(',') || cellStr.includes('"') || cellStr.includes('\n')) {
                return '"' + cellStr.replace(/"/g, '""') + '"';
              }
              return cellStr;
            }).join(',')
          ).join('\n');
          
          const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
          const link = document.createElement('a');
          const url = URL.createObjectURL(blob);
          
          const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
          link.setAttribute('href', url);
          link.setAttribute('download', `${sheetName}_update_${timestamp}.csv`);
          link.style.visibility = 'hidden';
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
          
          showNotification(`Plik CSV z danymi ${sheetName} został pobrany`, 'info');
          return true;
        } catch (error) {
          console.error('CSV download error:', error);
          showNotification(`Błąd podczas przygotowywania danych: ${error.message}`, 'error');
          return false;
        }
      }

      /** Alternative: Use Google Apps Script Web App for writing */
      async function updateSheetViaScript(sheetName, data) {
        try {
          // This would require a Google Apps Script web app URL
          // The script would handle writing to the actual Google Sheet
          const scriptUrl = 'YOUR_GOOGLE_APPS_SCRIPT_WEB_APP_URL';
          
          const response = await fetch(scriptUrl, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({
              sheetName: sheetName,
              data: data,
              action: 'update'
            })
          });
          
          if (!response.ok) {
            throw new Error(`Script response: ${response.status}`);
          }
          
          const result = await response.json();
          if (result.success) {
            showNotification(`Dane ${sheetName} zostały zapisane w Google Sheets`, 'success');
            return true;
          } else {
            throw new Error(result.error || 'Unknown error');
          }
        } catch (error) {
          console.error('Error updating sheet via script:', error);
          showNotification(`Błąd zapisu do Google Sheets: ${error.message}`, 'error');
          return false;
        }
      }

      /** Show notification to user */
      function showNotification(message, type = 'info') {
        const notification = document.createElement('div');
        notification.className = `notification notification-${type}`;
        notification.textContent = message;
        notification.style.cssText = `
          position: fixed;
          top: 20px;
          right: 20px;
          padding: 12px 20px;
          border-radius: 8px;
          color: white;
          font-weight: 500;
          z-index: 10000;
          max-width: 400px;
          background: ${type === 'success' ? '#28a745' : type === 'error' ? '#dc3545' : '#17a2b8'};
          box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        `;
        
        document.body.appendChild(notification);
        
        setTimeout(() => {
          notification.style.opacity = '0';
          notification.style.transition = 'opacity 0.3s ease';
          setTimeout(() => notification.remove(), 300);
        }, 3000);
      }

      /** Prepare teams data for saving */
      function prepareTeamsDataForSave() {
        const teams = Object.values(window._adminTeamsById || {});
        const data = [['team_id', 'team_name', 'class_id', 'logo_url', 'payment_status', 'notes']];
        
        teams.forEach(team => {
          data.push([
            team.team_id || '',
            team.team_name || '',
            team.class_id || '',
            team.logo_url || '',
            team.payment_status || '',
            team.notes || ''
          ]);
        });
        
        return data;
      }

      /** Prepare players data for saving */
      function preparePlayersDataForSave() {
        const players = window._adminPlayers || [];
        const data = [['player_id', 'first_name', 'last_name', 'class_id', 'is_captain', 'has_paid', 'consents_signed', 'notes', 'team_id']];
        
        players.forEach(player => {
          data.push([
            player.player_id || '',
            player.first_name || '',
            player.last_name || '',
            player.class_id || '',
            player.is_captain ? 'TRUE' : 'FALSE',
            player.has_paid ? 'TRUE' : 'FALSE',
            player.consents_signed ? 'TRUE' : 'FALSE',
            player.notes || '',
            player.team_id || ''
          ]);
        });
        
        return data;
      }

      /** Fetch all data from database sheets */
      async function fetchAllData() {
        
        const results = await Promise.allSettled([
          fetchCsv(SHEETS.PLAYERS),
          fetchCsv(SHEETS.TEAMS),
          fetchCsv(SHEETS.MATCHES_FOOTBALL),
          fetchCsv(SHEETS.MATCHES_BASKETBALL),
          fetchCsv(SHEETS.MATCHES_VOLLEYBALL),
          fetchCsv(SHEETS.LOG_FOOTBALL),
          fetchCsv(SHEETS.LOG_BASKETBALL),
          fetchCsv(SHEETS.LOG_VOLLEYBALL),
          fetchCsv(SHEETS.STATS_FOOTBALL),
          fetchCsv(SHEETS.STATS_BASKETBALL)
        ]);

        const data = {
          players: results[0].status === 'fulfilled' ? csvToArray(results[0].value) : null,
          teams: results[1].status === 'fulfilled' ? csvToArray(results[1].value) : null,
          matches_football: results[2].status === 'fulfilled' ? csvToArray(results[2].value) : null,
          matches_basketball: results[3].status === 'fulfilled' ? csvToArray(results[3].value) : null,
          matches_volleyball: results[4].status === 'fulfilled' ? csvToArray(results[4].value) : null,
          log_football: results[5].status === 'fulfilled' ? csvToArray(results[5].value) : null,
          log_basketball: results[6].status === 'fulfilled' ? csvToArray(results[6].value) : null,
          log_volleyball: results[7].status === 'fulfilled' ? csvToArray(results[7].value) : null,
          stats_football: results[8].status === 'fulfilled' ? csvToArray(results[8].value) : null,
          stats_basketball: results[9].status === 'fulfilled' ? csvToArray(results[9].value) : null,
          errors: results.filter(r => r.status === 'rejected').map(r => r.reason)
        };
        
        return data;
      }

      /* ---------------------- Data Parsers ---------------------- */
      
      /** Parse players table according to database structure */
      function parsePlayers(data) {
        if (!data || data.length < 2) return [];
        
        const headers = data[0].map(h => {
          let cleaned = (h || '').trim();
          if (cleaned.startsWith('"') && cleaned.endsWith('"')) {
            cleaned = cleaned.slice(1, -1);
          }
          return cleaned.toLowerCase();
        });
        const players = [];
        
        const fieldMap = {
          player_id: headers.findIndex(h => h.includes('player_id') || h.includes('id_zawodnika')),
          first_name: headers.findIndex(h => h.includes('first_name') || h.includes('imię') || h.includes('imie')),
          last_name: headers.findIndex(h => h.includes('last_name') || h.includes('nazwisko')),
          class_id: headers.findIndex(h => h.includes('class_id') || h.includes('klasa')),
          is_captain: headers.findIndex(h => h.includes('is_captain') || h.includes('kapitan')),
          has_paid: headers.findIndex(h => h.includes('has_paid') || h.includes('wpłata') || h.includes('wplacone')),
          consents_signed: headers.findIndex(h => h.includes('consents_signed') || h.includes('zgoda')),
          notes: headers.findIndex(h => h.includes('notes') || h.includes('uwagi')),
          team_id: headers.findIndex(h => h.includes('team_id') || h.includes('id_druzyny'))
        };
        
        for (let i = 1; i < data.length; i++) {
          const row = data[i];
          const player = {
            player_id: (row[fieldMap.player_id] || '').trim(),
            first_name: (row[fieldMap.first_name] || '').trim(),
            last_name: (row[fieldMap.last_name] || '').trim(),
            class_id: (row[fieldMap.class_id] || '').trim(),
            is_captain: String(row[fieldMap.is_captain] || '').trim().toLowerCase() === 'true',
            has_paid: String(row[fieldMap.has_paid] || '').trim().toLowerCase() === 'true',
            consents_signed: String(row[fieldMap.consents_signed] || '').trim().toLowerCase() === 'true',
            notes: (row[fieldMap.notes] || '').trim(),
            team_id: (row[fieldMap.team_id] || '').trim()
          };
          players.push(player);
        }
        
        return players;
      }
      
      /** Parse teams table according to database structure */
      function parseTeams(data) {
        if (!data || data.length < 2) return [];
        
        const headers = data[0].map(h => {
          let cleaned = (h || '').trim();
          if (cleaned.startsWith('"') && cleaned.endsWith('"')) {
            cleaned = cleaned.slice(1, -1);
          }
          return cleaned.toLowerCase();
        });
        const teams = [];
        
        const fieldMap = {
          team_id: headers.findIndex(h => h.includes('team_id') || h.includes('id_drużyny')),
          team_name: headers.findIndex(h => h.includes('team_name') || h.includes('nazwa')),
          class_id: headers.findIndex(h => h.includes('class_id') || h.includes('klasa')),
          logo_url: headers.findIndex(h => h.includes('logo_url') || h.includes('logo')),
          payment_status: headers.findIndex(h => h.includes('payment_status') || h.includes('płatność')),
          notes: headers.findIndex(h => h.includes('notes') || h.includes('notatki'))
        };
        
        for (let i = 1; i < data.length; i++) {
          const row = data[i];
          const team = {
            team_id: (row[fieldMap.team_id] || '').trim(),
            team_name: (row[fieldMap.team_name] || '').trim(),
            class_id: (row[fieldMap.class_id] || '').trim(),
            logo_url: (row[fieldMap.logo_url] || '').trim(),
            payment_status: (row[fieldMap.payment_status] || '').trim(),
            notes: (row[fieldMap.notes] || '').trim()
          };
          teams.push(team);
        }
        
        return teams;
      }
      
      /** Parse matches tables (football, basketball, volleyball) */
      function parseMatches(data, sport) {
        if (!data || data.length < 2) return [];
        
        const headers = data[0].map(h => (h || '').toLowerCase());
        const matches = [];
        
        const fieldMap = {
          match_id: headers.findIndex(h => h.includes('match_id') || h.includes('id_meczu')),
          team_a_id: headers.findIndex(h => h.includes('team_a_id') || h.includes('drużyna_a')),
          team_b_id: headers.findIndex(h => h.includes('team_b_id') || h.includes('drużyna_b')),
          score_a: headers.findIndex(h => h.includes('score_a') || h.includes('wynik_a')),
          score_b: headers.findIndex(h => h.includes('score_b') || h.includes('wynik_b')),
          date: headers.findIndex(h => h.includes('date') || h.includes('data')),
          time: headers.findIndex(h => h.includes('time') || h.includes('czas') || h === 'time'),
          place: headers.findIndex(h => h.includes('place') || h.includes('miejsce')),
          status: headers.findIndex(h => h.includes('status') || h.includes('stan')),
          referee: headers.findIndex(h => h.includes('referee') || h.includes('sędzia')),
          notatki: headers.findIndex(h => h.includes('notatki') || h.includes('notes'))
        };
        
        // Add sport-specific fields
        if (sport === 'volleyball') {
          fieldMap.set1_a = headers.findIndex(h => h.includes('set1_a'));
          fieldMap.set1_b = headers.findIndex(h => h.includes('set1_b'));
          fieldMap.set2_a = headers.findIndex(h => h.includes('set2_a'));
          fieldMap.set2_b = headers.findIndex(h => h.includes('set2_b'));
          fieldMap.set3_a = headers.findIndex(h => h.includes('set3_a'));
          fieldMap.set3_b = headers.findIndex(h => h.includes('set3_b'));
          fieldMap.final_sets_a = headers.findIndex(h => h.includes('final_sets_a'));
          fieldMap.final_sets_b = headers.findIndex(h => h.includes('final_sets_b'));
        }
        
        // Helper function to parse ISO date (2025-12-25T23:00:00.000Z) -> 2025-12-25
        function parseIsoDate(isoString) {
          if (!isoString) return '';
          if (typeof isoString !== 'string') return '';
          const parts = isoString.split('T');
          return parts[0] || '';
        }
        
        // Helper function to parse time values. Accepts ISO datetime (T) or plain HH:MM
        function parseIsoTime(isoString) {
          if (!isoString) return '';
          if (typeof isoString !== 'string') return '';
          // ISO datetime with T
          if (isoString.includes('T')) {
            const parts = isoString.split('T');
            if (parts.length < 2) return '';
            const timePart = parts[1];
            const timeComponents = timePart.split(':');
            if (timeComponents.length < 2) return '';
            return timeComponents[0].padStart(2,'0') + ':' + timeComponents[1];
          }
          // Plain HH:MM or HH:MM:SS
          const m = isoString.match(/(\d{1,2}:\d{2})/);
          return m ? m[1] : '';
        }
        
        for (let i = 1; i < data.length; i++) {
          const row = data[i];
          const rawDate = row[fieldMap.date] || '';
          const rawTime = row[fieldMap.time] || '';
          
          const match = {
            match_id: row[fieldMap.match_id] || '',
            team_a_id: row[fieldMap.team_a_id] || '',
            team_b_id: row[fieldMap.team_b_id] || '',
            score_a: row[fieldMap.score_a] || '',
            score_b: row[fieldMap.score_b] || '',
            date: parseIsoDate(rawDate),
            time: parseIsoTime(rawTime),
            place: row[fieldMap.place] || '',
            status: row[fieldMap.status] || '',
            referee: row[fieldMap.referee] || '',
            notatki: row[fieldMap.notatki] || '',
            sport: sport
          };
          
          // Add sport-specific fields
          if (sport === 'volleyball') {
            match.set1_a = row[fieldMap.set1_a] || '';
            match.set1_b = row[fieldMap.set1_b] || '';
            match.set2_a = row[fieldMap.set2_a] || '';
            match.set2_b = row[fieldMap.set2_b] || '';
            match.set3_a = row[fieldMap.set3_a] || '';
            match.set3_b = row[fieldMap.set3_b] || '';
            match.final_sets_a = row[fieldMap.final_sets_a] || '';
            match.final_sets_b = row[fieldMap.final_sets_b] || '';
          }
          
          matches.push(match);
        }
        
        return matches;
      }

      /**
       * Parse log/events CSV into structured event objects
       * Accepts common variants (id, summary, details) or detailed logs with match_id, timestamp, side, event_type, value, additional_info, operator
       */
      function parseLogEvents(data, sport) {
        if (!data || data.length < 2) return [];
        const headers = data[0].map(h => (h || '').toLowerCase().trim());

        const idx = {
          match_id: headers.findIndex(h => h.includes('match') || h === 'id' || h.includes('id_')),
          timestamp: headers.findIndex(h => h.includes('time') || h.includes('timestamp') || h.includes('date') || h.includes('czas')),
          side: headers.findIndex(h => h.includes('side') || h.includes('team') || h.includes('strona')),
          event_type: headers.findIndex(h => h.includes('event') || h.includes('type') || h.includes('summary') || h.includes('typ')),
          value: headers.findIndex(h => h.includes('value') || h.includes('wynik') || h.includes('score') || h.includes('wartosc')),
          additional_info: headers.findIndex(h => h.includes('details') || h.includes('info') || h.includes('additional') || h.includes('notat')),
          operator: headers.findIndex(h => h.includes('operator') || h.includes('user') || h.includes('author') || h.includes('op'))
        };

        const events = [];
        for (let i = 1; i < data.length; i++) {
          const row = data[i];
          const ev = {
            match_id: (row[idx.match_id] || row[0] || '').trim(),
            timestamp: (row[idx.timestamp] || '').trim(),
            side: (row[idx.side] || '').trim(),
            event_type: (row[idx.event_type] || '').trim(),
            value: (row[idx.value] || '').trim(),
            additional_info: (row[idx.additional_info] || '').trim(),
            operator: (row[idx.operator] || '').trim(),
            sport: sport
          };

          // Support older simple protokoly format: id,summary,details
          if ((!ev.event_type || ev.event_type === '') && headers.includes('summary') && headers.includes('details')) {
            const sIdx = headers.indexOf('summary');
            const dIdx = headers.indexOf('details');
            ev.event_type = (row[sIdx] || ev.event_type || '').trim();
            ev.additional_info = (row[dIdx] || ev.additional_info || '').trim();
          }

          events.push(ev);
        }

        return events;
      }

      /**
       * Parse stats CSV generically into objects keyed by header names
       */
      function parseStats(data, sport) {
        if (!data || data.length < 2) return [];
        const headers = data[0].map(h => (h || '').toLowerCase().trim());
        return data.slice(1).map(row => {
          const obj = { sport };
          headers.forEach((h, i) => {
            obj[h] = (row[i] || '').trim();
          });
          return obj;
        });
      }

      /** Build map and render (used after fetching CSV) - adapts whether sheet contains players or teams */
      function renderTeamsFromSheet(data) {
        if (!data || data.length < 2) {
          document.getElementById('teams-list').textContent = 'Brak danych drużyn.';
          return;
        }

        const parsed = parseTeamsAndPlayers(data);
        // store by id
        window._adminTeamsById = parsed.teamsById || {};

        // if players are present they are already attached, otherwise keep teams empty; convert to name-keyed map
        Object.values(window._adminTeamsById).forEach(t => t.players = t.players || []);

        // build name keyed
        const nameMap = {};
        Object.values(window._adminTeamsById).forEach(t => {
          nameMap[t.name] = t;
        });

        // if parser found players separately attach them
        if (parsed.players && parsed.players.length) {
          parsed.players.forEach(p => {
            const tid = p.teamId || 'UNKNOWN';
            if (!window._adminTeamsById[tid]) {
              window._adminTeamsById[tid] = { id: tid, name: tid, players: [] };
            }
            window._adminTeamsById[tid].players = window._adminTeamsById[tid].players || [];
            window._adminTeamsById[tid].players.push(p);
            nameMap[window._adminTeamsById[tid].name] = window._adminTeamsById[tid];
          });
        }

        setTeamsMap(nameMap);
        renderTeamsFromMap();
      }

      /**
       * Set teams map (name-keyed) and derive ID-keyed maps
       * @param {Object} nameMap - { teamName: teamObject }
       */
      function setTeamsMap(nameMap) {
        window._adminTeamsByName = nameMap || {};
        const byId = {};
        Object.values(window._adminTeamsByName).forEach(t => {
          const id = t.team_id || t.id || (t.team_name && String(t.team_name).trim()) || '';
          if (id) byId[id] = t;
        });
        window._adminTeamsById = byId;
        // also keep array form
        window._adminTeams = Object.values(byId);
      }

      /**
       * Render teams UI from the name-keyed map (window._adminTeamsByName)
       */
      function renderTeamsFromMap() {
        const container = document.getElementById('teams-list');
        if (!container) return;
        container.innerHTML = '';

        const map = window._adminTeamsByName || {};
        const names = Object.keys(map).sort((a,b) => a.localeCompare(b,'pl',{sensitivity:'base'}));

        if (names.length === 0) {
          container.textContent = 'Brak danych drużyn.';
          return;
        }

          // Render using admin styles (.team-card, .team-summary, .team-right, .player-list)
        names.forEach(name => {
          const team = map[name];

          const card = document.createElement('div');
          card.className = 'team-card';

          // Header summary
          const summary = document.createElement('div');
          summary.className = 'team-summary';

          const title = document.createElement('div');
          title.className = 'team-title';
          const displayName = team.team_name || team.name || name;
          const classe = team.class_id || team.classe || '';
          title.textContent = classe ? `${displayName} (${classe})` : displayName;

          const right = document.createElement('div');
          right.className = 'team-right';

          const count = document.createElement('span');
          count.className = 'team-count';
          count.textContent = `${(team.players || []).length} zawodników`;

          const actions = document.createElement('div');
          actions.className = 'team-actions';

          const editBtn = document.createElement('button');
          editBtn.className = 'edit-team';
          editBtn.dataset.teamId = team.team_id || team.id || '';
          editBtn.textContent = 'Edytuj';

          const deleteBtn = document.createElement('button');
          deleteBtn.className = 'delete-team';
          deleteBtn.dataset.teamId = team.team_id || team.id || '';
          deleteBtn.textContent = 'Usuń';

          const addPlayerBtn = document.createElement('button');
          addPlayerBtn.className = 'add-player-button';
          addPlayerBtn.dataset.teamId = team.team_id || team.id || '';
          addPlayerBtn.textContent = 'Dodaj zawodnika';

          actions.appendChild(editBtn);
          actions.appendChild(deleteBtn);
          actions.appendChild(addPlayerBtn);

          right.appendChild(count);
          right.appendChild(actions);

          summary.appendChild(title);
          summary.appendChild(right);

          card.appendChild(summary);

          // Meta / logo row
          const meta = document.createElement('div');
          meta.className = 'team-meta';

          const metaLeft = document.createElement('div');
          metaLeft.className = 'team-meta-left';

          const logo = document.createElement('img');
          logo.className = 'team-logo-compact';
          logo.src = team.logo_url || team.logo || '';
          if (!logo.src) logo.style.display = 'none';

          const info = document.createElement('div');
          info.className = 'team-info';
          info.innerHTML = `
            <div><strong>Nazwa:</strong> ${escapeHtml(displayName)}</div>
            <div><strong>Klasa:</strong> ${escapeHtml(classe)}</div>
            <div><strong>Wpłacone:</strong> ${escapeHtml(team.payment_status || team.wplacone_ilosc || '')}</div>
          `;

          metaLeft.appendChild(logo);
          metaLeft.appendChild(info);
          meta.appendChild(metaLeft);

          // Player list
          const playerList = document.createElement('div');
          playerList.className = 'player-list';

          (team.players || []).forEach(p => {
            const item = document.createElement('div');
            item.className = 'player-item';

            const left = document.createElement('div');
            left.className = 'player-left';

            const main = document.createElement('div');
            main.className = 'player-main';

            const nameSpan = document.createElement('div');
            nameSpan.textContent = `${p.first_name || p.first || ''} ${p.last_name || p.last || ''}`.trim();

            const metaSpan = document.createElement('div');
            metaSpan.className = 'player-meta';
            metaSpan.textContent = `${p.class_id || p.classe || ''}`;

            main.appendChild(nameSpan);
            main.appendChild(metaSpan);

            left.appendChild(main);

            const actionsP = document.createElement('span');
            actionsP.style.cssText = 'margin-left:10px;display:inline-flex;gap:6px;';

            const editP = document.createElement('button');
            editP.className = 'edit-player';
            editP.dataset.playerId = p.player_id || p.id || '';
            editP.dataset.teamId = team.team_id || team.id || '';
            editP.textContent = 'Edytuj';

            const delP = document.createElement('button');
            delP.className = 'delete-player';
            delP.dataset.playerId = p.player_id || p.id || '';
            delP.dataset.teamId = team.team_id || team.id || '';
            delP.textContent = 'Usuń';

            actionsP.appendChild(editP);
            actionsP.appendChild(delP);

            item.appendChild(left);
            item.appendChild(actionsP);

            playerList.appendChild(item);
          });

          card.appendChild(meta);
          card.appendChild(playerList);

          container.appendChild(card);
        });
      }

      /* Event delegation for team/player actions (single listener) */
      document.getElementById('teams-list').addEventListener('click', (e) => {
        const btn = e.target.closest('button');
        if (!btn) return;
        e.stopPropagation();

        // Edit team -> open modal
        if (btn.matches('.edit-team')) {
          const teamId = btn.dataset.teamId;
          const team = (window._adminTeamsById || {})[teamId];
          if (!team) return;

          // Fetch fresh data before opening modal
          showNotification('Pobieranie aktualnych danych...', 'info');
          
          fetchFreshTeamData(teamId).then(freshTeam => {
            if (freshTeam) {
              // Merge fresh data with existing team data (preserve players array)
              const updatedTeam = { ...team, ...freshTeam };
              if (team.players) {
                updatedTeam.players = team.players;
              }
              
              openTeamEditModal(updatedTeam, teamId);
            } else {
              showNotification('Błąd pobierania danych, używam lokalnej kopii', 'warning');
              openTeamEditModal(team, teamId);
            }
          }).catch(error => {
            console.error('Error fetching fresh team data:', error);
            showNotification('Błąd pobierania danych, używam lokalnej kopii', 'warning');
            openTeamEditModal(team, teamId);
          });
          
          return;
        }

        function openTeamEditModal(team, teamId) {
          const tpl = document.getElementById('team-edit-template');
          const node = tpl.content.cloneNode(true);
          const modal = node.querySelector('.modal');
          const form = node.querySelector('.edit-team-form');

          // Fill form with fresh data
          form.id.value = team.team_id || team.id || '';
          form.name.value = team.team_name || team.name || '';
          form.classe.value = team.class_id || team.classe || '';
          form.wplacone.value = team.payment_status || team.wplacone_ilosc || '';
          form.notes.value = team.notes || '';
          form.logo.value = team.logo_url || team.logo || '';

          form.querySelector('.cancel').addEventListener('click', () => modal.remove());
          form.querySelector('.save-team').addEventListener('click', async () => {
            // Store original values for comparison
            const originalValues = {
              name: team.name,
              classe: team.classe,
              wplacone_ilosc: team.wplacone_ilosc,
              notes: team.notes,
              logo: team.logo
            };
            
            // Update local data
            team.name = form.name.value.trim() || team.name;
            team.classe = form.classe.value.trim();
            team.wplacone_ilosc = form.wplacone.value;
            team.notes = form.notes.value.trim();
            team.logo = form.logo.value.trim();
            
            // Update the teams data structure
            team.team_name = team.name;
            team.class_id = team.classe;
            team.payment_status = team.wplacone_ilosc;
            team.notes = team.notes;
            team.logo_url = team.logo;

            // Find team row in Google Sheets
            const teamRow = findTeamRow(team.team_id || team.id);
            if (!teamRow) {
              showNotification('Błąd: Nie znaleziono wiersza drużyny', 'error');
              return;
            }

            // Update only changed cells
            const updates = [];
            
            // Check each field for changes
            if (originalValues.name !== team.name) {
              updates.push({ column: 'B', value: team.name });
            }
            if (originalValues.classe !== team.classe) {
              updates.push({ column: 'C', value: team.classe });
            }
            if (originalValues.logo !== team.logo) {
              updates.push({ column: 'D', value: team.logo });
            }
            if (originalValues.wplacone_ilosc !== team.wplacone_ilosc) {
              updates.push({ column: 'E', value: team.wplacone_ilosc });
            }
            if (originalValues.notes !== team.notes) {
              updates.push({ column: 'F', value: team.notes });
            }

            // Apply updates
            let success = true;
            for (const update of updates) {
              try {
                console.log(`Updating team cell ${update.column}${teamRow}: ${update.value}`);
                await updateSingleCell(SHEETS.TEAMS, `${update.column}${teamRow}`, update.value);
              } catch (error) {
                console.error('Error updating team cell:', error);
                success = false;
                break;
              }
            }
            
            if (success) {
              showNotification(`Drużyna zaktualizowana (${updates.length} pól zmienionych)`, 'success');
              // rebuild name map
              const nameMap = {};
              Object.values(window._adminTeamsById).forEach(t => { nameMap[t.team_name || t.name] = t; });
              setTeamsMap(nameMap);
              renderTeamsFromMap();
              modal.remove();
            } else {
              showNotification('Błąd podczas zapisywania zmian', 'error');
            }
          });

          document.body.appendChild(node);
          return;
        }

        // Delete team
        if (btn.matches('.delete-team')) {
          const teamId = btn.dataset.teamId;
          const team = (window._adminTeamsById || {})[teamId];
          if (!team) return;
          if (confirm(`Usuń drużynę "${team.name}"?`)) {
            delete window._adminTeamsById[teamId];
            const nameMap = {};
            Object.values(window._adminTeamsById).forEach(t => { nameMap[t.name] = t; });
            setTeamsMap(nameMap);
            renderTeamsFromMap();
          }
          return;
        }

        // Edit player -> open modal
        if (btn.matches('.edit-player')) {
          const teamId = btn.dataset.teamId;
          const playerId = btn.dataset.playerId;
          const team = (window._adminTeamsById || {})[teamId];
          if (!team) return;
          const player = (team.players || []).find(p => String(p.id) === String(playerId));
          if (!player) return;

          // Fetch fresh data before opening modal
          showNotification('Pobieranie aktualnych danych...', 'info');
          
          fetchFreshPlayerData(playerId).then(freshPlayer => {
            if (freshPlayer) {
              // Merge fresh data with existing player data
              const updatedPlayer = { ...player, ...freshPlayer };
              openPlayerEditModal(updatedPlayer, teamId, team);
            } else {
              showNotification('Błąd pobierania danych, używam lokalnej kopii', 'warning');
              openPlayerEditModal(player, teamId, team);
            }
          }).catch(error => {
            console.error('Error fetching fresh player data:', error);
            showNotification('Błąd pobierania danych, używam lokalnej kopii', 'warning');
            openPlayerEditModal(player, teamId, team);
          });
          
          return;
        }

        function openPlayerEditModal(player, teamId, team) {
          const tpl = document.getElementById('player-edit-template');
          const node = tpl.content.cloneNode(true);
          const modal = node.querySelector('.modal');
          const form = node.querySelector('.edit-player-form');

          // fill team selector
          const sel = form.team;
          sel.innerHTML = '';
          console.log('Available teams for selector:', Object.values(window._adminTeamsById));
          
          Object.values(window._adminTeamsById).forEach(t => {
            const opt = document.createElement('option');
            opt.value = t.team_id || t.id;
            opt.textContent = t.team_name || t.name;
            if ((t.team_id || t.id) === teamId) opt.selected = true;
            sel.appendChild(opt);
          });
          
          console.log('Team selector options:', sel.innerHTML);

          // Fill form with fresh data
          form.id.value = player.player_id || player.id || '';
          form.first.value = player.first_name || player.first || '';
          form.last.value = player.last_name || player.last || '';
          form.classe.value = player.class_id || player.classe || '';
          form.captain.checked = !!(player.consents_signed || player.zgoda_rodo);
          form.zgoda_rodo.checked = !!(player.consents_signed || player.zgoda_rodo);
          form.zgoda_gra.checked = !!(player.consents_signed || player.zgoda_gra);
          form.wplacone.checked = !!(player.has_paid || player.wplacone);

          form.querySelector('.cancel').addEventListener('click', () => modal.remove());
          form.querySelector('.save-player').addEventListener('click', async () => {
            const newTeamId = form.team.value;
            
            // Store original values for comparison
            const originalValues = {
              first: player.first,
              last: player.last,
              classe: player.classe,
              captain: player.captain,
              zgoda_rodo: player.zgoda_rodo,
              zgoda_gra: player.zgoda_gra,
              wplacone: player.wplacone,
              team_id: player.team_id
            };
            
            // Update local player data
            player.first = form.first.value.trim();
            player.last = form.last.value.trim();
            player.classe = form.classe.value.trim();
            player.captain = !!form.captain.checked;
            player.zgoda_rodo = !!form.zgoda_rodo.checked;
            player.zgoda_gra = !!form.zgoda_gra.checked;
            player.wplacone = !!form.wplacone.checked;

            // Update the players data structure
            player.first_name = player.first;
            player.last_name = player.last;
            player.class_id = player.classe;
            player.is_captain = player.captain;
            player.consents_signed = player.zgoda_rodo && player.zgoda_gra;
            player.has_paid = player.wplacone;
            player.team_id = newTeamId;

            // Find player row in Google Sheets
            const playerRow = findPlayerRow(player.id);
            if (!playerRow) {
              showNotification('Błąd: Nie znaleziono wiersza zawodnika', 'error');
              return;
            }

            // Update only changed cells
            const updates = [];
            
            // Check each field for changes
            if (originalValues.first !== player.first) {
              updates.push({ column: 'B', value: player.first });
            }
            if (originalValues.last !== player.last) {
              updates.push({ column: 'C', value: player.last });
            }
            if (originalValues.classe !== player.classe) {
              updates.push({ column: 'D', value: player.classe });
            }
            if (originalValues.captain !== player.captain) {
              updates.push({ column: 'E', value: player.captain ? 'TRUE' : 'FALSE' });
            }
            if (originalValues.wplacone !== player.wplacone) {
              updates.push({ column: 'F', value: player.wplacone ? 'TRUE' : 'FALSE' });
            }
            if (originalValues.zgoda_rodo !== player.zgoda_rodo || originalValues.zgoda_gra !== player.zgoda_gra) {
              updates.push({ column: 'G', value: (player.zgoda_rodo && player.zgoda_gra) ? 'TRUE' : 'FALSE' });
            }
            if (originalValues.team_id !== newTeamId) {
              updates.push({ column: 'I', value: newTeamId });
            }

            // Apply updates
            let success = true;
            for (const update of updates) {
              try {
                console.log(`Updating cell ${update.column}${playerRow}: ${update.value}`);
                await updateSingleCell(SHEETS.PLAYERS, `${update.column}${playerRow}`, update.value);
              } catch (error) {
                console.error('Error updating cell:', error);
                success = false;
                break;
              }
            }

            // if team changed, move player
            if (newTeamId && newTeamId !== teamId) {
              // Remove from old team
              if (team && team.players) {
                team.players = team.players.filter(p => String(p.id) !== String(player.id));
              }
              
              // Add to new team
              const newTeam = window._adminTeamsById[newTeamId];
              if (newTeam) {
                newTeam.players = newTeam.players || [];
                newTeam.players.push(player);
              } else {
                console.error('New team not found:', newTeamId);
                showNotification('Błąd: Nowa drużyna nie została znaleziona', 'error');
                return;
              }
            }
            
            if (success) {
              showNotification(`Zawodnik zaktualizowany (${updates.length} pól zmienionych)`, 'success');
              const nameMap = {};
              Object.values(window._adminTeamsById).forEach(t => { nameMap[t.team_name || t.name] = t; });
              setTeamsMap(nameMap);
              renderTeamsFromMap();
              modal.remove();
            } else {
              showNotification('Błąd podczas zapisywania zmian', 'error');
            }
          });

          document.body.appendChild(node);
          return;
        }

        // Add player
        if (btn.matches('.add-player-button')) {
          const teamId = btn.dataset.teamId;
          const team = (window._adminTeamsById || {})[teamId];
          if (!team) return;
          
          openAddPlayerModal(teamId, team);
          return;
        }

        // Add team
        if (btn.matches('.add-team-button')) {
          openAddTeamModal();
          return;
        }

        // Delete player
        if (btn.matches('.delete-player')) {
          const teamId = btn.dataset.teamId;
          const playerId = btn.dataset.playerId;
          const team = (window._adminTeamsById || {})[teamId];
          if (!team) return;
          const player = (team.players || []).find(p => String(p.id) === String(playerId));
          if (!player) return;
          if (confirm(`Usuń zawodnika "${player.first || ''} ${player.last || ''}"?`)) {
            team.players = (team.players || []).filter(p => String(p.id) !== String(playerId));
            const nameMap = {};
            Object.values(window._adminTeamsById).forEach(t => { nameMap[t.name] = t; });
            setTeamsMap(nameMap);
            renderTeamsFromMap();
          }
          return;
        }
      });

      /* ---------------------- Matches Rendering ---------------------- */
      function getTeamNameById(teamId) {
        const teams = window._adminTeamsById || {};
        
        // Try both string and number comparison
        const team = Object.values(teams).find(t => 
          String(t.team_id) === String(teamId) || 
          t.team_id === teamId
        );
        
        return team ? team.team_name : teamId;
      }

      function formatMatchScore(match) {
        if (match.sport === 'volleyball' && match.sets) {
          const setsA = match.sets.team_a.filter(s => s > 0).join('-');
          const setsB = match.sets.team_b.filter(s => s > 0).join('-');
          return `${match.score_a}:${match.score_b} (${setsA}/${setsB})`;
        }
        return `${match.score_a}:${match.score_b}`;
      }

      function getMatchStatusText(status) {
        const statusMap = {
          'Planned': 'Zaplanowany',
          'Live': 'W trakcie', 
          'Finished': 'Zakończony',
          'Cancelled': 'Odwołany'
        };
        return statusMap[status] || status;
      }

      async function renderMatches() {
        const sport = document.getElementById('sport-type').value;
        const type = document.getElementById('competition-type').value;
        const list = document.getElementById('matches-list');
        list.innerHTML = '';

        const matches = (window._adminMatches || {})[sport] || [];
        const filteredMatches = matches.filter(m => {
          // Filter by competition type if we have that info
          return true; // For now, show all matches for the selected sport
        });

        if (!filteredMatches.length) {
          list.textContent = `Brak meczów dla dyscypliny ${sport}.`;
          return;
        }

        filteredMatches.forEach(m => {
          const tpl = document.getElementById('match-template');
          const node = tpl.content.cloneNode(true);
          
          const teamAName = getTeamNameById(m.team_a_id);
          const teamBName = getTeamNameById(m.team_b_id);
          
          node.querySelector('.match-title').textContent = `${teamAName} — ${teamBName} (${m.date || 'Brak daty'})`;
          node.querySelector('.m-date').textContent = m.date || 'Brak daty';
          node.querySelector('.m-teamA').textContent = teamAName;
          node.querySelector('.m-teamB').textContent = teamBName;
          node.querySelector('.m-score').textContent = formatMatchScore(m);

          const showBtn = node.querySelector('.show-protocol');
          const protocol = node.querySelector('.protocol');
          const protocolContent = node.querySelector('.protocol-content');

          showBtn.addEventListener('click', async () => {
            protocolContent.innerHTML = 'Ładowanie protokołu...';
            try {
              const events = (window._adminLogs || {})[sport] || [];
              const matchEvents = events.filter(e => e.match_id === m.match_id);
              
              if (!matchEvents.length) {
                protocolContent.innerHTML = '<em>Brak protokołu dla tego meczu.</em>';
              } else {
                let html = '<div class="protocol-events">';
                html += `<h4>Protokół meczu ${m.match_id} (${sport})</h4>`;
                matchEvents.forEach(event => {
                  html += `
                    <div class="event">
                      <span class="event-time">${event.timestamp}</span>
                      <span class="event-side">${event.side}</span>
                      <span class="event-type">${event.event_type}</span>
                      <span class="event-value">${event.value}</span>
                      ${event.additional_info ? `<span class="event-info">${event.additional_info}</span>` : ''}
                      <span class="event-operator">Operator: ${event.operator}</span>
                    </div>
                  `;
                });
                html += '</div>';
                protocolContent.innerHTML = html;
              }
            } catch (err) {
              protocolContent.innerHTML = '<span class="error">Błąd podczas pobierania protokołu.</span>';
              console.error(err);
            }

            protocol.style.display = protocol.style.display === 'none' ? 'block' : 'none';
          });

          list.appendChild(node);
        });
      }

      /* ---------------------- Tabs & Init ---------------------- */
      function setupTabs() {
        document.querySelectorAll('.tab-btn').forEach(btn => btn.addEventListener('click', () => {
          document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('tab-active'));
          btn.classList.add('tab-active');
          showTab(btn.dataset.tab);
        }));
      }

      function showTab(name) {
        const teamsPanel = document.getElementById('teams-panel');
        const matchesPanel = document.getElementById('matches-panel');
        const schedulePanel = document.getElementById('schedule-panel');
        const plannerPanel = document.getElementById('planner-panel');
        
        if (teamsPanel) teamsPanel.style.display = name === 'teams' ? 'block' : 'none';
        if (matchesPanel) matchesPanel.style.display = name === 'matches' ? 'block' : 'none';
        if (schedulePanel) {
          schedulePanel.style.display = name === 'schedule' ? 'block' : 'none';
          if (name === 'schedule') {
            initSchedulePanelInternal();
          }
        }
        if (plannerPanel) {
          plannerPanel.style.display = name === 'planner' ? 'block' : 'none';
          if (name === 'planner') {
            renderPlannerHeader();
            renderPlannerGrid();
            renderUnassignedMatches();
          }
        }
        // Initialize schedule panel when first shown OR force reinitialize
        if (name === 'schedule') {
          console.log('Schedule tab selected, forcing reinitialization...');
          window._scheduleInitialized = false; // Force reinitialization
          setTimeout(() => {
            console.log('Running initSchedulePanel...');
            initSchedulePanel();
            window._scheduleInitialized = true;
          }, 100);
        }
      }

      async function loadAdminData() {
        
        const loadingEl = document.getElementById('teams-loading');
        const errorEl = document.getElementById('teams-error');
        loadingEl.style.display = 'block';
        errorEl.style.display = 'none';

        try {
          let data;

          if (typeof USE_SAMPLE_DATA !== 'undefined' && USE_SAMPLE_DATA) {
            // Use embedded samples for development/testing
            console.info('Admin panel: using sample CSV data (USE_SAMPLE_DATA=true)');
            
            // Parse sample data with new structure
            data = {
              players: parsePlayers(csvToArray(SAMPLE_PLAYERS_CSV)),
              teams: parseTeams(csvToArray(SAMPLE_TEAMS_CSV)),
              matches_football: parseMatches(csvToArray(SAMPLE_MATCHES_CSV), 'football'),
              matches_basketball: [],
              matches_volleyball: [],
              log_football: [],
              log_basketball: [],
              log_volleyball: [],
              stats_football: [],
              stats_basketball: [],
              errors: []
            };
          } else {
            // Fetch real data from Google Sheets
            console.log('Fetching real data from Google Sheets...');
            const rawData = await fetchAllData();
            
            data = {
              players: rawData.players ? parsePlayers(rawData.players) : [],
              teams: rawData.teams ? parseTeams(rawData.teams) : [],
              matches_football: rawData.matches_football ? parseMatches(rawData.matches_football, 'football') : [],
              matches_basketball: rawData.matches_basketball ? parseMatches(rawData.matches_basketball, 'basketball') : [],
              matches_volleyball: rawData.matches_volleyball ? parseMatches(rawData.matches_volleyball, 'volleyball') : [],
              log_football: rawData.log_football ? parseLogEvents(rawData.log_football, 'football') : [],
              log_basketball: rawData.log_basketball ? parseLogEvents(rawData.log_basketball, 'basketball') : [],
              log_volleyball: rawData.log_volleyball ? parseLogEvents(rawData.log_volleyball, 'volleyball') : [],
              stats_football: rawData.stats_football ? parseStats(rawData.stats_football, 'football') : [],
              stats_basketball: rawData.stats_basketball ? parseStats(rawData.stats_basketball, 'basketball') : [],
              errors: rawData.errors || []
            };
          }

          // Store data globally
          window._adminData = data; // Store all parsed data
          window._adminPlayers = data.players;
          window._adminTeams = data.teams;
          window._adminMatches = {
            football: data.matches_football,
            basketball: data.matches_basketball,
            volleyball: data.matches_volleyball
          };
          window._adminLogs = {
            football: data.log_football,
            basketball: data.log_basketball,
            volleyball: data.log_volleyball
          };
          window._adminStats = {
            football: data.stats_football,
            basketball: data.stats_basketball
          };

          // Build team lookup maps
          const teamsById = {};
          const teamsByName = {};
          
          data.teams.forEach(team => {
            teamsById[team.team_id] = team;
            teamsByName[team.team_name] = team;
          });
          
          window._adminTeamsById = teamsById;
          window._adminTeamsByName = teamsByName;

          // Mapuj nazwy drużyn do meczów
          const attachTeamNamesToMatches = (matches) => {
            matches.forEach(match => {
              if (match.team_a_id && !match.team_a_name) {
                const teamA = teamsById[match.team_a_id];
                match.team_a_name = teamA ? (teamA.team_name || teamA.name) : match.team_a_id;
              }
              if (match.team_b_id && !match.team_b_name) {
                const teamB = teamsById[match.team_b_id];
                match.team_b_name = teamB ? (teamB.team_name || teamB.name) : match.team_b_id;
              }
            });
          };
          
          attachTeamNamesToMatches(data.matches_football);
          attachTeamNamesToMatches(data.matches_basketball);
          attachTeamNamesToMatches(data.matches_volleyball);

          // Attach players to teams
          data.players.forEach((player, index) => {
            const team = teamsById[player.team_id] || teamsById[player.class_id];
            
            if (team) {
              team.players = team.players || [];
              team.players.push({
                id: player.player_id,
                first: player.first_name,
                last: player.last_name,
                classe: player.class_id,
                captain: player.is_captain,
                zgoda_rodo: player.consents_signed,
                zgoda_gra: player.consents_signed,
                wplacone: player.has_paid,
                teamId: team.team_id
              });
            }
          });

          // Render teams and matches
          renderTeamsFromMap();
          renderMatches();
          
          // Populate class filter with available classes
          populateClassFilter();

          // Additionally, fetch latest teams from Google Sheets and refresh UI (overrides sample teams)
          fetchAndRenderTeams().catch(e => console.warn('fetchAndRenderTeams failed:', e && e.message));
          
          // Załaduj zaplanowane mecze do planera (jeśli są już dostępne)
          if (window._adminMatches) {
            updatePlannerMatchesFromDb();
          }

        } catch (err) {
          console.error('Error loading admin data:', err.message);
          
          let errorMessage = 'Błąd podczas pobierania danych: ' + err.message;
          
          // Check if it's a CORS error
          if (err.message.includes('Could not fetch data from Google Sheets')) {
            errorMessage = err.message;
          } else if (err.message.includes('Failed to fetch') || err.message.includes('CORS')) {
            errorMessage = `CORS Error: Nie można pobierać danych z Google Sheets. ` +
              `Sprawdź czy arkusz jest udostępniony publicznie (Share → "Anyone with the link can view"). ` +
              `Otwórz DevTools (F12 → Network) aby zobaczyć szczegóły błędu.`;
          }
          
          errorEl.style.display = 'block';
          errorEl.textContent = errorMessage;
          
          // Try to load sample data as fallback
          console.warn('Attempting to load sample data as fallback...');
          window.USE_SAMPLE_DATA = true;
          try {
            loadAdminData();
          } catch (fallbackErr) {
            console.error('Fallback to sample data also failed:', fallbackErr);
          }
        } finally {
          loadingEl.style.display = 'none';
        }
      }

      document.getElementById('sport-type').addEventListener('change', renderMatches);
      document.getElementById('competition-type').addEventListener('change', renderMatches);

      // init
      document.addEventListener('DOMContentLoaded', () => {
        setupTabs();
        showTab('teams');
        loadAdminData();
        setInterval(loadAdminData, 300000); // Refresh every 5 minutes
        
        // Setup search and filters
        setupTeamsSearchAndFilter();
      });

      /** Setup search and filter functionality for teams */
      function setupTeamsSearchAndFilter() {
        const searchInput = document.getElementById('team-search');
        const clearBtn = document.getElementById('clear-search');
        const classFilter = document.getElementById('class-filter');
        const paymentFilter = document.getElementById('payment-filter');
        const playersFilter = document.getElementById('players-filter');
        const teamsCount = document.getElementById('teams-count');

        // Search input handler
        searchInput.addEventListener('input', (e) => {
          const value = e.target.value.trim();
          clearBtn.style.display = value ? 'block' : 'none';
          filterAndRenderTeams();
        });

        // Clear search button
        clearBtn.addEventListener('click', () => {
          searchInput.value = '';
          clearBtn.style.display = 'none';
          filterAndRenderTeams();
        });

        // Filter handlers
        classFilter.addEventListener('change', filterAndRenderTeams);
        paymentFilter.addEventListener('change', filterAndRenderTeams);
        playersFilter.addEventListener('change', filterAndRenderTeams);
      }

      /** Filter and render teams based on search and filters */
      function filterAndRenderTeams() {
        const searchInput = document.getElementById('team-search');
        const classFilter = document.getElementById('class-filter');
        const paymentFilter = document.getElementById('payment-filter');
        const playersFilter = document.getElementById('players-filter');
        const teamsCount = document.getElementById('teams-count');

        const searchTerm = searchInput.value.trim().toLowerCase();
        const classValue = classFilter.value;
        const paymentValue = paymentFilter.value;
        const playersValue = playersFilter.value;

        // Get all teams
        const allTeams = Object.values(window._adminTeamsById || {});
        
        // Filter teams
        const filteredTeams = allTeams.filter(team => {
          // Search filter - search in both team and player data
          if (searchTerm) {
            let foundInTeam = false;
            
            // Search in team data
            const teamName = (team.team_name || team.name || '').toLowerCase();
            const teamClass = (team.class_id || team.classe || '').toLowerCase();
            const teamNotes = (team.notes || '').toLowerCase();
            
            if (teamName.includes(searchTerm) || 
                teamClass.includes(searchTerm) || 
                teamNotes.includes(searchTerm)) {
              foundInTeam = true;
            }
            
            // Search in players data
            if (!foundInTeam && team.players && team.players.length > 0) {
              for (const player of team.players) {
                const playerFirst = (player.first_name || player.first || '').toLowerCase();
                const playerLast = (player.last_name || player.last || '').toLowerCase();
                const playerClass = (player.class_id || player.classe || '').toLowerCase();
                const playerFull = `${playerFirst} ${playerLast}`;
                
                if (playerFirst.includes(searchTerm) || 
                    playerLast.includes(searchTerm) || 
                    playerFull.includes(searchTerm) || 
                    playerClass.includes(searchTerm)) {
                  foundInTeam = true;
                  break;
                }
              }
            }
            
            if (!foundInTeam) {
              return false;
            }
          }

          // Class filter
          if (classValue) {
            const teamClass = team.class_id || team.classe || '';
            if (teamClass !== classValue) {
              return false;
            }
          }

          // Payment filter
          if (paymentValue) {
            const paymentStatus = team.payment_status || team.wplacone_ilosc || '';
            const hasPaid = paymentStatus && paymentStatus.toLowerCase() !== 'brak' && paymentStatus !== '';
            
            if (paymentValue === 'paid' && !hasPaid) {
              return false;
            }
            if (paymentValue === 'unpaid' && hasPaid) {
              return false;
            }
          }

          // Players filter
          if (playersValue) {
            const hasPlayers = team.players && team.players.length > 0;
            
            if (playersValue === 'has-players' && !hasPlayers) {
              return false;
            }
            if (playersValue === 'no-players' && hasPlayers) {
              return false;
            }
          }

          return true;
        });

        // Update count
        teamsCount.textContent = `${filteredTeams.length} drużyn`;

        // Render filtered teams
        renderFilteredTeams(filteredTeams);
      }

      /** Render filtered teams */
      function renderFilteredTeams(teams) {
        const container = document.getElementById('teams-list');
        if (!container) return;

        container.innerHTML = '';

        if (teams.length === 0) {
          container.innerHTML = '<div class="no-results">Brak drużyn pasujących do filtrów</div>';
          return;
        }

        // Create both maps for rendering
        const teamsById = {};
        const teamsByName = {};
        
        teams.forEach(team => {
          const teamId = team.team_id || team.id;
          const teamName = team.team_name || team.name;
          
          teamsById[teamId] = team;
          teamsByName[teamName] = team;
        });

        // Temporarily replace global maps
        const originalTeamsById = window._adminTeamsById;
        const originalTeamsByName = window._adminTeamsByName;
        
        window._adminTeamsById = teamsById;
        window._adminTeamsByName = teamsByName;
        
        // Render teams
        renderTeamsFromMap();
        
        // Restore original maps
        window._adminTeamsById = originalTeamsById;
        window._adminTeamsByName = originalTeamsByName;
      }

      /** Populate class filter with unique classes */
      function populateClassFilter() {
        const classFilter = document.getElementById('class-filter');
        if (!classFilter) return;

        const allTeams = Object.values(window._adminTeamsById || {});
        const classes = [...new Set(allTeams.map(team => team.class_id || team.classe || '').filter(Boolean))];
        
        // Clear existing options except first
        classFilter.innerHTML = '<option value="">Wszystkie klasy</option>';
        
        // Add class options
        classes.sort().forEach(className => {
          const option = document.createElement('option');
          option.value = className;
          option.textContent = className;
          classFilter.appendChild(option);
        });
      }

      /* ---------------------- Schedule Functions ---------------------- */
      
      /** Initialize schedule panel */
      function initSchedulePanel() {
        // Check if teams data is available
        if (!window._adminTeamsById || Object.keys(window._adminTeamsById).length === 0) {
          // Wait a bit and try again
          setTimeout(() => {
            if (!window._adminTeamsById || Object.keys(window._adminTeamsById).length === 0) {
              console.warn('Teams data still not available, proceeding with dummy teams');
            }
            initSchedulePanelInternal();
          }, 1000);
          return;
        }
        
        initSchedulePanelInternal();
      }
      
      function initSchedulePanelInternal() {
        // Setup event listeners
        const addMatchBtn = document.getElementById('add-match-btn');
        const scheduleList = document.getElementById('schedule-list');
        const scheduleCalendar = document.getElementById('schedule-calendar');
        
        if (addMatchBtn) {
          addMatchBtn.addEventListener('click', openAddMatchModal);
        }
        
        // Setup filters
        setupScheduleFilters();
        
        // Setup calendar
        setupCalendar();
        
        // Load schedule data and wait for it to complete before rendering
        loadScheduleData().catch(error => {
          console.error('Error loading schedule data:', error);
        });
      }
      
      /** Setup schedule filters */
      function setupScheduleFilters() {
        const sportFilter = document.getElementById('schedule-sport-filter');
        const statusFilter = document.getElementById('schedule-status-filter');
        const dateFilter = document.getElementById('schedule-date-filter');
        
        if (sportFilter) sportFilter.addEventListener('change', filterAndRenderSchedule);
        if (statusFilter) statusFilter.addEventListener('change', filterAndRenderSchedule);
        if (dateFilter) dateFilter.addEventListener('change', filterAndRenderSchedule);
      }
      
      /** Clear schedule filters */
      function clearScheduleFilters() {
        const sportFilter = document.getElementById('schedule-sport-filter');
        const statusFilter = document.getElementById('schedule-status-filter');
        const dateFilter = document.getElementById('schedule-date-filter');
        
        if (sportFilter) sportFilter.value = '';
        if (statusFilter) statusFilter.value = '';
        if (dateFilter) dateFilter.value = '';
        
        filterAndRenderSchedule();
        showNotification('Filtry zostały wyczyszczone', 'success');
      }
      
      /** Setup calendar */
      function setupCalendar() {
        const prevBtn = document.getElementById('prev-period');
        const nextBtn = document.getElementById('next-period');
        const monthViewBtn = document.getElementById('month-view');
        const weekViewBtn = document.getElementById('week-view');
        const todayBtn = document.getElementById('today-btn');
        
        if (prevBtn) prevBtn.addEventListener('click', () => navigatePeriod(-1));
        if (nextBtn) nextBtn.addEventListener('click', () => navigatePeriod(1));
        if (monthViewBtn) monthViewBtn.addEventListener('click', () => setCalendarView('month'));
        if (weekViewBtn) weekViewBtn.addEventListener('click', () => setCalendarView('week'));
        if (todayBtn) todayBtn.addEventListener('click', () => goToToday());
        
        // Initialize calendar state
        window._calendarView = 'month';
        window._currentCalendarDate = new Date();
        
        renderCalendar();
      }
      
      /** Navigate calendar period */
      function navigatePeriod(direction) {
        const currentDate = window._currentCalendarDate || new Date();
        
        if (window._calendarView === 'month') {
          currentDate.setMonth(currentDate.getMonth() + direction);
        } else {
          currentDate.setDate(currentDate.getDate() + (direction * 7));
        }
        
        window._currentCalendarDate = currentDate;
        renderCalendar();
      }
      
      /** Set calendar view */
      function setCalendarView(view) {
        window._calendarView = view;
        
        // Update button states
        const monthBtn = document.getElementById('month-view');
        const weekBtn = document.getElementById('week-view');
        
        if (monthBtn && weekBtn) {
          monthBtn.classList.toggle('active', view === 'month');
          weekBtn.classList.toggle('active', view === 'week');
        }
        
        renderCalendar();
      }
      
      /** Go to today */
      function goToToday() {
        window._currentCalendarDate = new Date();
        renderCalendar();
      }
      
      /** Render calendar */
      function renderCalendar() {
        const currentDate = window._currentCalendarDate || new Date();
        const view = window._calendarView || 'month';
        
        console.log('Rendering calendar:', {
          currentDate: currentDate,
          view: view,
          scheduleData: window._scheduleData,
          dataLength: window._scheduleData?.length || 0
        });
        
        // Update title
        const titleEl = document.getElementById('current-period');
        if (titleEl) {
          if (view === 'month') {
            const monthNames = ['Styczeń', 'Luty', 'Marzec', 'Kwiecień', 'Maj', 'Czerwiec', 
                               'Lipiec', 'Sierpień', 'Wrzesień', 'Październik', 'Listopad', 'Grudzień'];
            titleEl.textContent = `${monthNames[currentDate.getMonth()]} ${currentDate.getFullYear()}`;
          } else {
            const weekStart = getWeekStart(currentDate);
            const weekEnd = getWeekEnd(currentDate);
            titleEl.textContent = `${formatDate(weekStart)} - ${formatDate(weekEnd)}`;
          }
        }
        
        // Toggle view containers
        const monthContainer = document.getElementById('month-view-container');
        const weekContainer = document.getElementById('week-view-container');
        
        if (view === 'month') {
          monthContainer.style.display = 'block';
          weekContainer.style.display = 'none';
          renderMonthView(currentDate);
        } else {
          monthContainer.style.display = 'none';
          weekContainer.style.display = 'block';
          renderWeekView(currentDate);
        }
      }
      
      /** Get week start date */
      function getWeekStart(date) {
        const d = new Date(date);
        const day = d.getDay();
        const diff = d.getDate() - day + (day === 0 ? -6 : 1); // Adjust for Monday start
        return new Date(d.setDate(diff));
      }
      
      /** Get week end date */
      function getWeekEnd(date) {
        const d = new Date(date);
        const weekStart = getWeekStart(d);
        return new Date(weekStart.setDate(weekStart.getDate() + 6));
      }
      
      /** Render month view */
      function renderMonthView(currentDate) {
        const calendarDays = document.getElementById('calendar-days');
        if (!calendarDays) return;
        
        const year = currentDate.getFullYear();
        const month = currentDate.getMonth();
        const firstDay = new Date(year, month, 1);
        const lastDay = new Date(year, month + 1, 0);
        const prevLastDay = new Date(year, month, 0);
        
        const startDate = firstDay.getDay() === 0 ? 6 : firstDay.getDay() - 1; // Monday start
        
        calendarDays.innerHTML = '';
        
        // Previous month days
        for (let i = startDate - 1; i >= 0; i--) {
          const day = prevLastDay.getDate() - i;
          const dayEl = createCalendarDay(day, true, false, new Date(year, month - 1, day));
          calendarDays.appendChild(dayEl);
        }
        
        // Current month days
        for (let day = 1; day <= lastDay.getDate(); day++) {
          const date = new Date(year, month, day);
          const isToday = isDateToday(date);
          const dayEl = createCalendarDay(day, false, isToday, date);
          calendarDays.appendChild(dayEl);
        }
        
        // Next month days
        const totalCells = calendarDays.children.length;
        const remainingCells = 42 - totalCells; // 6 weeks * 7 days
        for (let day = 1; day <= remainingCells; day++) {
          const dayEl = createCalendarDay(day, true, false, new Date(year, month + 1, day));
          calendarDays.appendChild(dayEl);
        }
      }
      
      /** Render week view */
      function renderWeekView(currentDate) {
        const weekGrid = document.getElementById('week-grid');
        if (!weekGrid) return;
        
        weekGrid.innerHTML = '';
        
        const weekStart = getWeekStart(currentDate);
        const weekDays = [];
        
        // Generate week days
        for (let i = 0; i < 7; i++) {
          const day = new Date(weekStart);
          day.setDate(weekStart.getDate() + i);
          weekDays.push(day);
        }
        
        // Generate time slots from 6:00 to 23:00
        for (let hour = 6; hour <= 23; hour++) {
          const timeSlot = document.createElement('div');
          timeSlot.className = 'week-time-slot';
          
          // Time cell
          const timeCell = document.createElement('div');
          timeCell.className = 'week-time-cell';
          timeCell.textContent = `${hour.toString().padStart(2, '0')}:00`;
          timeSlot.appendChild(timeCell);
          
          // Day cells
          for (let dayIndex = 0; dayIndex < 7; dayIndex++) {
            const dayCell = document.createElement('div');
            dayCell.className = 'week-day-cell';
            dayCell.dataset.date = formatDate(weekDays[dayIndex]);
            dayCell.dataset.hour = hour;
            
            // Add matches for this time slot
            const matches = getMatchesForTimeSlot(weekDays[dayIndex], hour);
            matches.forEach(match => {
              const matchBlock = createWeekMatchBlock(match);
              dayCell.appendChild(matchBlock);
            });
            
            timeSlot.appendChild(dayCell);
          }
          
          weekGrid.appendChild(timeSlot);
        }
      }
      
      /** Get matches for time slot */
      function getMatchesForTimeSlot(date, hour) {
        const dateStr = formatDate(date);
        const hourStr = hour.toString().padStart(2, '0');
        
        return (window._scheduleData || []).filter(match => {
          const matchDate = match.date || match.dateStr;
          const matchHour = match.time ? match.time.split(':')[0] : null;
          
          return (matchDate === dateStr || matchDate === date.toISOString().split('T')[0]) &&
                 matchHour === hourStr;
        });
      }
      
      /** Create week match block */
      function createWeekMatchBlock(match) {
        const matchBlock = document.createElement('div');
        matchBlock.className = `week-match-block ${match.sport_type}`;
        matchBlock.title = `${match.team_a_name} vs ${match.team_b_name} - ${match.time || '---'}`;
        
        const teams = `${match.team_a_name.substring(0, 3)} vs ${match.team_b_name.substring(0, 3)}`;
        matchBlock.textContent = teams;
        
        matchBlock.addEventListener('click', (e) => {
          e.stopPropagation();
          openMatchDetails(match.id);
        });
        
        return matchBlock;
      }
      
      /** Check if date is today */
      function isDateToday(date) {
        const today = new Date();
        return date.getDate() === today.getDate() &&
               date.getMonth() === today.getMonth() &&
               date.getFullYear() === today.getFullYear();
      }
      
      /** Create calendar day element */
      function createCalendarDay(day, isOtherMonth, isToday, date, isWeekView = false) {
        const dayEl = document.createElement('div');
        dayEl.className = 'calendar-day';
        if (isOtherMonth) dayEl.classList.add('other-month');
        if (isToday) dayEl.classList.add('today');
        if (isWeekView) dayEl.classList.add('week-view');
        
        const dayNumber = document.createElement('div');
        dayNumber.className = 'calendar-day-number';
        dayNumber.textContent = day;
        dayEl.appendChild(dayNumber);
        
        // Only add matches for month view (not week view)
        if (!isWeekView) {
          // Add matches for this day
          const dayMatches = getMatchesForDate(date);
          if (dayMatches.length > 0) {
            const matchesContainer = document.createElement('div');
            matchesContainer.className = 'calendar-day-matches';
            
            dayMatches.slice(0, 3).forEach(match => {
              const matchEl = createCalendarMatchElement(match);
              matchesContainer.appendChild(matchEl);
            });
            
            if (dayMatches.length > 3) {
              const moreEl = document.createElement('div');
              moreEl.className = 'calendar-more-matches';
              moreEl.textContent = `+${dayMatches.length - 3} więcej`;
              matchesContainer.appendChild(moreEl);
            }
            
            dayEl.appendChild(matchesContainer);
          }
        }
        
        dayEl.addEventListener('click', () => openMatchDetailsForDate(date));
        
        return dayEl;
      }
      
      /** Get matches for date */
      function getMatchesForDate(date) {
        const dateStr = formatDate(date);
        // Try both formats: YYYY-MM-DD and DD.MM.YYYY
        const matches = (window._scheduleData || []).filter(match => {
          return match.date === dateStr || 
                 match.date === date.toISOString().split('T')[0]; // YYYY-MM-DD format
        });
        console.log(`Getting matches for ${dateStr} (${date.toISOString().split('T')[0]}):`, matches.length, matches);
        return matches;
      }
      
      /** Create calendar match element */
      function createCalendarMatchElement(match) {
        const matchEl = document.createElement('div');
        matchEl.className = `calendar-match-item ${match.sport_type}`;
        matchEl.title = `${match.team_a_name} vs ${match.team_b_name} - ${match.time || '---'}`;
        
        const time = match.time || '---';
        const teams = `${match.team_a_name.substring(0, 3)} vs ${match.team_b_name.substring(0, 3)}`;
        
        matchEl.innerHTML = `<strong>${time}</strong> ${teams}`;
        
        matchEl.addEventListener('click', (e) => {
          e.stopPropagation();
          openMatchDetails(match.id);
        });
        
        return matchEl;
      }
      
      /** Open match details for date */
      function openMatchDetailsForDate(date) {
        const matches = getMatchesForDate(date);
        if (matches.length > 0) {
          // Open first match for now
          openMatchDetails(matches[0].id);
        }
      }
      
      /** Filter schedule by date */
      function filterByDate(dateStr) {
        const dateFilter = document.getElementById('schedule-date-filter');
        if (dateFilter) {
          dateFilter.value = dateStr;
          filterAndRenderSchedule();
        }
      }
      
      /** Open match details */
      function openMatchDetails(matchId) {
        const match = (window._scheduleData || []).find(m => m.id === matchId);
        if (match) {
          openMatchDetailsModal(match);
        }
      }
      
      /** Load schedule data */
      async function loadScheduleData() {
        const loadingEl = document.getElementById('schedule-loading');
        const errorEl = document.getElementById('schedule-error');
        
        console.log('🔄 Starting loadScheduleData()...');
        
        try {
          if (loadingEl) loadingEl.style.display = 'block';
          if (errorEl) errorEl.style.display = 'none';
          
          // Load matches from all sport sheets
          const matches = [];
          const processedIds = new Set(); // Track processed match IDs to avoid duplicates
          
          for (const sport of ['football', 'basketball', 'volleyball']) {
            try {
              const sheetName = `matches_${sport}`;
              console.log(`Fetching data from ${sheetName}...`);
              const csv = await fetchCsv(sheetName);
              console.log(`Successfully fetched ${sheetName}, CSV length: ${csv.length}`);
              const matchesArray = csvToArray(csv);
              const sportMatches = parseScheduleMatches(matchesArray, sport);
              
              // Filter out duplicates by ID
              const uniqueMatches = sportMatches.filter(match => {
                if (processedIds.has(match.id)) {
                  return false;
                }
                processedIds.add(match.id);
                return true;
              });
              
              matches.push(...uniqueMatches);
            } catch (error) {
              console.error(`❌ Error loading ${sport} matches:`, error);
              // Don't add sample data - we want real data only
            }
          }
          
          window._scheduleData = matches;
          
          // Wypisz pobrane dane
          console.log('📊 POBRANE DANE O MECZACH:');
          console.log('=====================================');
          const footballMatches = matches.filter(m => m.sport_type === 'football');
          const basketballMatches = matches.filter(m => m.sport_type === 'basketball');
          const volleyballMatches = matches.filter(m => m.sport_type === 'volleyball');
          
          if (footballMatches.length > 0) {
            console.log(`⚽ PIŁKA NOŻNA (${footballMatches.length} meczów):`);
            footballMatches.forEach(m => {
              console.log(`  ${m.id}: ${m.team_a_name} vs ${m.team_b_name}`);
              console.log(`    Data: ${m.date} | Czas: ${m.time}`);
              console.log(`    Wynik: ${m.score_a}:${m.score_b} | Sędzia: ${m.referee || '-'}`);
              console.log(`    Miejsce: ${m.place || '-'} | Status: ${m.status || '-'}`);
              if (m.notes) console.log(`    Notatki: ${m.notes}`);
            });
          }
          
          if (basketballMatches.length > 0) {
            console.log(`🏀 KOSZYKÓWKA (${basketballMatches.length} meczów):`);
            basketballMatches.forEach(m => {
              console.log(`  ${m.id}: ${m.team_a_name} vs ${m.team_b_name}`);
              console.log(`    Data: ${m.date} | Czas: ${m.time}`);
              console.log(`    Wynik: ${m.score_a}:${m.score_b} | Sędzia: ${m.referee || '-'}`);
              console.log(`    Miejsce: ${m.place || '-'} | Status: ${m.status || '-'}`);
              if (m.notes) console.log(`    Notatki: ${m.notes}`);
            });
          }
          
          if (volleyballMatches.length > 0) {
            console.log(`🏐 SIATKÓWKA (${volleyballMatches.length} meczów):`);
            volleyballMatches.forEach(m => {
              console.log(`  ${m.id}: ${m.team_a_name} vs ${m.team_b_name}`);
              console.log(`    Data: ${m.date} | Czas: ${m.time}`);
              console.log(`    Sety: ${m.set1_a}-${m.set1_b} | ${m.set2_a}-${m.set2_b} | ${m.set3_a}-${m.set3_b}`);
              console.log(`    Wynik końcowy: ${m.final_sets_a}:${m.final_sets_b} | Sędzia: ${m.referee || '-'}`);
              console.log(`    Miejsce: ${m.place || '-'} | Status: ${m.status || '-'}`);
              if (m.notes) console.log(`    Notatki: ${m.notes}`);
            });
          }
          
          console.log('=====================================');
          console.log(`✅ Razem załadowano: ${matches.length} meczów`);
          console.log('=====================================');
          
          if (matches.length === 0) {
            showNotification('Brak danych o meczach w Google Sheets. Upewnij się, że arkusze matches_*, istnieją.', 'warning');
          } else {
            showNotification(`Załadowano ${matches.length} meczów z Google Sheets`, 'success');
          }
          
          filterAndRenderSchedule();
          renderCalendar();
          
        } catch (error) {
          console.error('Error in loadScheduleData:', error);
          if (loadingEl) loadingEl.style.display = 'none';
          if (errorEl) {
            errorEl.style.display = 'block';
            errorEl.textContent = 'Błąd podczas ładowania harmonogramu: ' + (error.message || error);
          }
        }
      }
      
      /** Render calendar */
      function renderCalendar() {
        const currentDate = window._currentCalendarDate || new Date();
        const view = window._calendarView || 'month';
        
        console.log('Rendering calendar:', {
          currentDate: currentDate,
          view: view,
          scheduleData: window._scheduleData,
          dataLength: window._scheduleData?.length || 0
        });
        
        // Update title
        const titleEl = document.getElementById('current-period');
        if (titleEl) {
          if (view === 'month') {
            const monthNames = ['Styczeń', 'Luty', 'Marzec', 'Kwiecień', 'Maj', 'Czerwiec', 
                               'Lipiec', 'Sierpień', 'Wrzesień', 'Październik', 'Listopad', 'Grudzień'];
            titleEl.textContent = `${monthNames[currentDate.getMonth()]} ${currentDate.getFullYear()}`;
          } else {
            const weekStart = getWeekStart(currentDate);
            const weekEnd = getWeekEnd(currentDate);
            titleEl.textContent = `${formatDate(weekStart)} - ${formatDate(weekEnd)}`;
          }
        }
        
        // Toggle view containers
        const monthContainer = document.getElementById('month-view-container');
        const weekContainer = document.getElementById('week-view-container');
        
        if (view === 'month') {
          monthContainer.style.display = 'block';
          weekContainer.style.display = 'none';
          renderMonthView(currentDate);
        } else {
          monthContainer.style.display = 'none';
          weekContainer.style.display = 'block';
          renderWeekView(currentDate);
        }
      }
      
      /** Get week start date */
      function getWeekStart(date) {
        const d = new Date(date);
        const day = d.getDay();
        const diff = d.getDate() - day + (day === 0 ? -6 : 1); // Adjust for Monday start
        return new Date(d.setDate(diff));
      }
      
      /** Get week end date */
      function getWeekEnd(date) {
        const d = new Date(date);
        const weekStart = getWeekStart(d);
        return new Date(weekStart.setDate(weekStart.getDate() + 6));
      }
      
      /** Render month view */
      function renderMonthView(currentDate) {
        const calendarDays = document.getElementById('calendar-days');
        if (!calendarDays) return;
        
        const year = currentDate.getFullYear();
        const month = currentDate.getMonth();
        const firstDay = new Date(year, month, 1);
        const lastDay = new Date(year, month + 1, 0);
        const prevLastDay = new Date(year, month, 0);
        
        const startDate = firstDay.getDay() === 0 ? 6 : firstDay.getDay() - 1; // Monday start
        
        calendarDays.innerHTML = '';
        
        // Previous month days
        for (let i = startDate - 1; i >= 0; i--) {
          const day = prevLastDay.getDate() - i;
          const dayEl = createCalendarDay(day, true, false, new Date(year, month - 1, day));
          calendarDays.appendChild(dayEl);
        }
        
        // Current month days
        for (let day = 1; day <= lastDay.getDate(); day++) {
          const date = new Date(year, month, day);
          const isToday = isDateToday(date);
          const dayEl = createCalendarDay(day, false, isToday, date);
          calendarDays.appendChild(dayEl);
        }
        
        // Next month days
        const totalCells = calendarDays.children.length;
        const remainingCells = 42 - totalCells; // 6 weeks * 7 days
        for (let day = 1; day <= remainingCells; day++) {
          const dayEl = createCalendarDay(day, true, false, new Date(year, month + 1, day));
          calendarDays.appendChild(dayEl);
        }
      }
      
      /** Render week view */
      function renderWeekView(currentDate) {
        const weekGrid = document.getElementById('week-grid');
        if (!weekGrid) return;
        
        weekGrid.innerHTML = '';
        
        const weekStart = getWeekStart(currentDate);
        const weekDays = [];
        
        // Generate week days
        for (let i = 0; i < 7; i++) {
          const day = new Date(weekStart);
          day.setDate(weekStart.getDate() + i);
          weekDays.push(day);
        }
        
        // Generate time slots from 6:00 to 23:00
        for (let hour = 6; hour <= 23; hour++) {
          const timeSlot = document.createElement('div');
          timeSlot.className = 'week-time-slot';
          
          // Time cell
          const timeCell = document.createElement('div');
          timeCell.className = 'week-time-cell';
          timeCell.textContent = `${hour.toString().padStart(2, '0')}:00`;
          timeSlot.appendChild(timeCell);
          
          // Day cells
          for (let dayIndex = 0; dayIndex < 7; dayIndex++) {
            const dayCell = document.createElement('div');
            dayCell.className = 'week-day-cell';
            dayCell.dataset.date = formatDate(weekDays[dayIndex]);
            dayCell.dataset.hour = hour;
            
            // Add matches for this time slot
            const matches = getMatchesForTimeSlot(weekDays[dayIndex], hour);
            matches.forEach(match => {
              const matchBlock = createWeekMatchBlock(match);
              dayCell.appendChild(matchBlock);
            });
            
            timeSlot.appendChild(dayCell);
          }
          
          weekGrid.appendChild(timeSlot);
        }
      }
      
      /** Get matches for time slot */
      function getMatchesForTimeSlot(date, hour) {
        const dateStr = formatDate(date);
        const hourStr = hour.toString().padStart(2, '0');
        
        return (window._scheduleData || []).filter(match => {
          const matchDate = match.date || match.dateStr;
          const matchHour = match.time ? match.time.split(':')[0] : null;
          
          return (matchDate === dateStr || matchDate === date.toISOString().split('T')[0]) &&
                 matchHour === hourStr;
        });
      }
      
      /** Create week match block */
      function createWeekMatchBlock(match) {
        const matchBlock = document.createElement('div');
        matchBlock.className = `week-match-block ${match.sport_type}`;
        matchBlock.title = `${match.team_a_name} vs ${match.team_b_name} - ${match.time || '---'}`;
        
        const teams = `${match.team_a_name.substring(0, 3)} vs ${match.team_b_name.substring(0, 3)}`;
        matchBlock.textContent = teams;
        
        matchBlock.addEventListener('click', (e) => {
          e.stopPropagation();
          openMatchDetails(match.id);
        });
        
        return matchBlock;
      }
      
      /** Check if date is today */
      function isDateToday(date) {
        const today = new Date();
        return date.getDate() === today.getDate() &&
               date.getMonth() === today.getMonth() &&
               date.getFullYear() === today.getFullYear();
      }
      
      /** Create calendar day element */
      function createCalendarDay(day, isOtherMonth, isToday, date, isWeekView = false) {
        const dayEl = document.createElement('div');
        dayEl.className = 'calendar-day';
        if (isOtherMonth) dayEl.classList.add('other-month');
        if (isToday) dayEl.classList.add('today');
        if (isWeekView) dayEl.classList.add('week-view');
        
        const dayNumber = document.createElement('div');
        dayNumber.className = 'calendar-day-number';
        dayNumber.textContent = day;
        dayEl.appendChild(dayNumber);
        
        // Only add matches for month view (not week view)
        if (!isWeekView) {
          // Add matches for this day
          const dayMatches = getMatchesForDate(date);
          if (dayMatches.length > 0) {
            const matchesContainer = document.createElement('div');
            matchesContainer.className = 'calendar-day-matches';
            
            dayMatches.slice(0, 3).forEach(match => {
              const matchEl = createCalendarMatchElement(match);
              matchesContainer.appendChild(matchEl);
            });
            
            if (dayMatches.length > 3) {
              const moreEl = document.createElement('div');
              moreEl.className = 'calendar-more-matches';
              moreEl.textContent = `+${dayMatches.length - 3} więcej`;
              matchesContainer.appendChild(moreEl);
            }
            
            dayEl.appendChild(matchesContainer);
          }
        }
        
        dayEl.addEventListener('click', () => openMatchDetailsForDate(date));
        
        return dayEl;
      }
      
      /** Get matches for date */
      function getMatchesForDate(date) {
        const dateStr = formatDate(date);
        // Try both formats: YYYY-MM-DD and DD.MM.YYYY
        const matches = (window._scheduleData || []).filter(match => {
          return match.date === dateStr || 
                 match.date === date.toISOString().split('T')[0]; // YYYY-MM-DD format
        });
        console.log(`Getting matches for ${dateStr} (${date.toISOString().split('T')[0]}):`, matches.length, matches);
        return matches;
      }
      
      /** Create calendar match element */
      function createCalendarMatchElement(match) {
        const matchEl = document.createElement('div');
        matchEl.className = `calendar-match-item ${match.sport_type}`;
        matchEl.title = `${match.team_a_name} vs ${match.team_b_name} - ${match.time || '---'}`;
        
        const time = match.time || '---';
        const teams = `${match.team_a_name.substring(0, 3)} vs ${match.team_b_name.substring(0, 3)}`;
        
        matchEl.innerHTML = `<strong>${time}</strong> ${teams}`;
        
        matchEl.addEventListener('click', (e) => {
          e.stopPropagation();
          openMatchDetails(match.id);
        });
        
        return matchEl;
      }
      
      /** Open match details for date */
      function openMatchDetailsForDate(date) {
        const matches = getMatchesForDate(date);
        if (matches.length > 0) {
          // Open first match for now
          openMatchDetails(matches[0].id);
        }
      }
      
      /** Filter schedule by date */
      function filterByDate(dateStr) {
        const dateFilter = document.getElementById('schedule-date-filter');
        if (dateFilter) {
          dateFilter.value = dateStr;
          filterAndRenderSchedule();
        }
      }
      
      /** Open match details */
      function openMatchDetails(matchId) {
        const match = (window._scheduleData || []).find(m => m.id === matchId);
        if (match) {
          openMatchDetailsModal(match);
        }
      }
      
      /** Load schedule data */

      
      /** Get sample matches for testing */
      function getSampleMatches(sportType) {
        const today = new Date();
        const tomorrow = new Date(today);
        tomorrow.setDate(tomorrow.getDate() + 1);
        const nextWeek = new Date(today);
        nextWeek.setDate(nextWeek.getDate() + 7);
        
        const sportNames = {
          football: 'Piłka Nożna',
          basketball: 'Koszykówka', 
          volleyball: 'Siatkówka'
        };
        
        const teams = Object.values(window._adminTeamsById || {});
        if (teams.length < 2) {
          // Create dummy teams if no real teams exist
          teams.push(
            { team_id: 'team_1', team_name: 'Orły', name: 'Orły' },
            { team_id: 'team_2', team_name: 'Sokoły', name: 'Sokoły' },
            { team_id: 'team_3', team_name: 'Lwy', name: 'Lwy' },
            { team_id: 'team_4', team_name: 'Twardziele', name: 'Twardziele' }
          );
        }
        
        const matches = [
          {
            id: `sample_${sportType}_1`,
            sport_type: sportType,
            competition_type: 'liga',
            date: today.toISOString().split('T')[0],
            time: '16:00',
            team_a: teams[0]?.team_id || 'team_1',
            team_b: teams[1]?.team_id || 'team_2',
            team_a_name: teams[0]?.team_name || teams[0]?.name || 'Orły',
            team_b_name: teams[1]?.team_name || teams[1]?.name || 'Sokoły',
            result: sportType === 'football' ? '2:1' : sportType === 'basketball' ? '45:52' : '',
            location: 'Boisko szkolne',
            referee: 'Jan Kowalski',
            status: 'completed',
            notes: `Przykładowy mecz ${sportNames[sportType]}`
          },
          {
            id: `sample_${sportType}_2`,
            sport_type: sportType,
            competition_type: 'liga',
            date: tomorrow.toISOString().split('T')[0],
            time: '17:30',
            team_a: teams[2]?.team_id || 'team_3',
            team_b: teams[3]?.team_id || 'team_4',
            team_a_name: teams[2]?.team_name || teams[2]?.name || 'Lwy',
            team_b_name: teams[3]?.team_name || teams[3]?.name || 'Twardziele',
            result: '',
            location: 'Sala gimnastyczna',
            referee: 'Anna Nowak',
            status: 'planned',
            notes: `Planowany mecz ${sportNames[sportType]}`
          },
          {
            id: `sample_${sportType}_3`,
            sport_type: sportType,
            competition_type: 'puchar',
            date: nextWeek.toISOString().split('T')[0],
            time: '15:00',
            team_a: teams[0]?.team_id || 'team_1',
            team_b: teams[2]?.team_id || 'team_3',
            team_a_name: teams[0]?.team_name || teams[0]?.name || 'Orły',
            team_b_name: teams[2]?.team_name || teams[2]?.name || 'Lwy',
            result: '',
            location: 'Stadion miejski',
            referee: 'Piotr Wiśniewski',
            status: 'planned',
            notes: `Mecz pucharowy ${sportNames[sportType]}`
          }
        ];
        
        return matches;
      }
      
      /** Parse schedule matches from CSV */
      function parseScheduleMatches(matchesArray, sportType) {
        if (matchesArray.length < 2) return [];
        
        const headers = matchesArray[0].map(h => h.toLowerCase().trim());
        const matches = [];
        
        console.log(`Parsing ${sportType} matches with headers:`, headers);
        
        for (let i = 1; i < matchesArray.length; i++) {
          const row = matchesArray[i];
          if (row.length < Math.min(3, headers.length)) continue;
          
          // Exact field mapping based on Google Sheets structure
          // A: match_id, B: poziom_meczu, C: date, D: team_a_id, E: team_b_id, 
          // F: score_a, G: score_b, H: place, I: referee, J: Time, K: status, L: notatki
          
          const matchId = row[headers.findIndex(h => h.includes('match_id'))] || 
                        row[0] || `${sportType}_match_${i}`;
          
          const competitionType = row[headers.findIndex(h => h.includes('poziom_meczu'))] || 
                                row[1] || 'liga';
          
          const date = row[headers.findIndex(h => h.includes('date'))] || 
                      row[2] || '';
          
          const teamAId = row[headers.findIndex(h => h.includes('team_a_id'))] || 
                        row[3] || '';
          
          const teamBId = row[headers.findIndex(h => h.includes('team_b_id'))] || 
                        row[4] || '';
          
          const scoreA = row[headers.findIndex(h => h.includes('score_a'))] || 
                        row[5] || '';
          
          const scoreB = row[headers.findIndex(h => h.includes('score_b'))] || 
                        row[6] || '';
          
          const location = row[headers.findIndex(h => h.includes('place'))] || 
                         row[7] || '';
          
          const referee = row[headers.findIndex(h => h.includes('referee'))] || 
                         row[8] || '';
          
          const time = row[headers.findIndex(h => h.includes('time'))] || 
                      row[9] || '';
          
          const status = row[headers.findIndex(h => h.includes('status'))] || 
                        row[10] || 'planned';
          
          const notes = row[headers.findIndex(h => h.includes('notatki'))] || 
                       row[11] || '';
          
          const match = {
            id: matchId,
            sport_type: sportType,
            competition_type: competitionType.toLowerCase(),
            date: date,
            time: time,
            team_a: teamAId,
            team_b: teamBId,
            result: (scoreA && scoreB && scoreA !== '' && scoreB !== '') ? `${scoreA}:${scoreB}` : '',
            location: location,
            referee: referee,
            status: status.toLowerCase() === 'planned' ? 'planned' : 
                   status.toLowerCase() === 'completed' || status.toLowerCase() === 'zakończony' ? 'completed' : 
                   status.toLowerCase() === 'cancelled' || status.toLowerCase() === 'odwołany' ? 'cancelled' : 
                   'planned',
            notes: notes
          };
          
          // Try to get team names from teams data
          const teamA = window._adminTeamsById?.[match.team_a];
          const teamB = window._adminTeamsById?.[match.team_b];
          
          match.team_a_name = teamA?.team_name || teamA?.name || `Drużyna ${match.team_a}`;
          match.team_b_name = teamB?.team_name || teamB?.name || `Drużyna ${match.team_b}`;
          
          // Auto-detect completed status if result exists but status is not set
          if (match.result && match.result !== '' && match.result !== ':' && match.status === 'planned') {
            match.status = 'completed';
          }
          
          matches.push(match);
          console.log(`Parsed match ${i}:`, match);
        }
        
        console.log(`Total ${sportType} matches parsed:`, matches.length);
        return matches;
      }
      
      /** Filter and render schedule */
      function filterAndRenderSchedule() {
        console.log('filterAndRenderSchedule called');
        
        const sportFilter = document.getElementById('schedule-sport-filter');
        const statusFilter = document.getElementById('schedule-status-filter');
        const dateFilter = document.getElementById('schedule-date-filter');
        const scheduleList = document.getElementById('schedule-list');
        
        console.log('DOM elements found:', {
          sportFilter: !!sportFilter,
          statusFilter: !!statusFilter,
          dateFilter: !!dateFilter,
          scheduleList: !!scheduleList
        });
        
        if (!scheduleList) {
          console.error('schedule-list element not found!');
          return;
        }
        
        const allMatches = window._scheduleData || [];
        console.log('All matches:', allMatches.length);
        
        // Apply filters - but ensure we show all matches if no filters are selected
        let filteredMatches = allMatches.filter(match => {
          // Only apply sport filter if a value is selected (not empty string)
          if (sportFilter && sportFilter.value && match.sport_type !== sportFilter.value) {
            return false;
          }
          
          // Only apply status filter if a value is selected (not empty string)
          if (statusFilter && statusFilter.value && match.status !== statusFilter.value) {
            return false;
          }
          
          // Only apply date filter if a value is selected (not empty string)
          if (dateFilter && dateFilter.value && match.date !== dateFilter.value) {
            return false;
          }
          
          return true;
        });
        
        console.log('Filtered matches:', filteredMatches.length);
        console.log('Active filters:', {
          sport: sportFilter?.value || 'none',
          status: statusFilter?.value || 'none', 
          date: dateFilter?.value || 'none'
        });
        
        // Sort by date and time
        filteredMatches.sort((a, b) => {
          const dateCompare = a.date.localeCompare(b.date);
          if (dateCompare !== 0) return dateCompare;
          return (a.time || '').localeCompare(b.time || '');
        });
        
        renderScheduleList(filteredMatches);
      }
      
      /** Render schedule list */
      function renderScheduleList(matches) {
        const scheduleList = document.getElementById('schedule-list');
        if (!scheduleList) {
          return;
        }
        
        scheduleList.innerHTML = '';
        
        if (matches.length === 0) {
          
          // Check if we have any data at all
          const totalMatches = window._scheduleData?.length || 0;
          if (totalMatches === 0) {
            scheduleList.innerHTML = `
              <div class="no-results">
                <h3>Brak meczów w harmonogramie</h3>
                <p>Brak danych o meczach w systemie. Możesz dodać mecze używając przycisku "+ Dodaj Mecz" lub wygenerować kolejkę.</p>
                <button class="add-match-button" onclick="openAddMatchModal()">+ Dodaj pierwszy mecz</button>
              </div>
            `;
          } else {
            scheduleList.innerHTML = `
              <div class="no-results">
                <h3>Brak meczów spełniających kryteria filtrów</h3>
                <p>Znaleziono ${totalMatches} meczów w systemie, ale żaden nie pasuje do wybranych filtrów.</p>
                <button class="clear-filters-button" onclick="clearScheduleFilters()">Wyczyść filtry</button>
              </div>
            `;
          }
          return;
        }
        
        // Add summary information
        const summaryDiv = document.createElement('div');
        summaryDiv.className = 'schedule-summary';
        summaryDiv.innerHTML = `
          <div class="schedule-summary-info">
            <span class="schedule-count">Wyświetlane mecze: ${matches.length}</span>
            <span class="schedule-total">Całkowita liczba meczów: ${window._scheduleData?.length || 0}</span>
          </div>
        `;
        scheduleList.appendChild(summaryDiv);
        
        matches.forEach((match, index) => {
          console.log(`Rendering match ${index + 1}:`, match);
          
          const matchItem = document.createElement('div');
          matchItem.className = 'schedule-item';
          
          const sportNames = {
            football: 'Piłka Nożna',
            basketball: 'Koszykówka',
            volleyball: 'Siatkówka'
          };
          
          const statusNames = {
            planned: 'Zaplanowany',
            completed: 'Zakończony',
            cancelled: 'Odwołany'
          };
          
          // Show all data, even if empty
          matchItem.innerHTML = `
            <div class="schedule-header">
              <div class="schedule-title">
                ${match.team_a_name || `Drużyna A (${match.team_a || 'Brak ID'})`} vs 
                ${match.team_b_name || `Drużyna B (${match.team_b || 'Brak ID'})`}
              </div>
              <div class="schedule-meta">
                <span class="schedule-badge ${match.sport_type}">${sportNames[match.sport_type] || match.sport_type || 'Brak dyscypliny'}</span>
                <span class="schedule-badge ${match.status}">${statusNames[match.status] || match.status || 'Brak statusu'}</span>
                <span class="schedule-badge competition">${match.competition_type || 'liga'}</span>
              </div>
            </div>
            <div class="schedule-details">
              <div class="schedule-detail">
                <span class="schedule-detail-label">ID:</span>
                <span class="schedule-detail-value">${match.id || 'Brak ID'}</span>
              </div>
              <div class="schedule-detail">
                <span class="schedule-detail-label">Data:</span>
                <span class="schedule-detail-value">${formatDate(match.date)}</span>
              </div>
              <div class="schedule-detail">
                <span class="schedule-detail-label">Godzina:</span>
                <span class="schedule-detail-value">${match.time || '---'}</span>
              </div>
              <div class="schedule-detail">
                <span class="schedule-detail-label">Miejsce:</span>
                <span class="schedule-detail-value">${match.location || '---'}</span>
              </div>
              <div class="schedule-detail">
                <span class="schedule-detail-label">Wynik:</span>
                <span class="schedule-detail-value">${match.result || '---'}</span>
              </div>
              <div class="schedule-detail">
                <span class="schedule-detail-label">Sędzia:</span>
                <span class="schedule-detail-value">${match.referee || '---'}</span>
              </div>
              ${match.notes ? `
              <div class="schedule-detail">
                <span class="schedule-detail-label">Notatki:</span>
                <span class="schedule-detail-value">${match.notes}</span>
              </div>
              ` : ''}
            </div>
            <div class="schedule-actions">
              <button class="edit-match" onclick="openMatchDetailsModal(${JSON.stringify(match).replace(/"/g, '&quot;')})">Edytuj</button>
              <button class="delete-match" onclick="deleteMatch('${match.id}')">Usuń</button>
            </div>
          `;
          
          scheduleList.appendChild(matchItem);
        });
      }
      
      /** Format date */
      function formatDate(date) {
        if (!date) return '---';
        
        // If it's already a string, return as is
        if (typeof date === 'string') {
          return date;
        }
        
        // If it's a Date object, format it
        if (date instanceof Date) {
          return date.toLocaleDateString('pl-PL', { day: '2-digit', month: '2-digit', year: 'numeric' });
        }
        
        return '---';
      }
      
      /** Open add match modal */
      function openAddMatchModal() {
        const tpl = document.getElementById('match-details-template');
        const node = tpl.content.cloneNode(true);
        const modal = node.querySelector('.modal');
        const form = node.querySelector('.match-details-form');
        
        // Change modal title
        const title = modal.querySelector('h3');
        if (title) title.textContent = 'Dodaj Nowy Mecz';
        
        // Clear form
        form.reset();
        form['match-id'].value = generateNewMatchId();
        
        // Populate team selectors
        populateTeamSelectors(form);
        
        // Set default values
        form['match-date'].value = new Date().toISOString().split('T')[0];
        form['match-time'].value = '16:00';
        form['status'].value = 'planned';
        
        // Setup event listeners
        form.querySelector('.cancel').addEventListener('click', () => modal.remove());
        form.querySelector('.save-match').addEventListener('click', () => saveMatch(modal, form));
        form.querySelector('.delete-match').style.display = 'none';
        
        document.body.appendChild(node);
      }
      
      /** Open match details modal */
      function openMatchDetailsModal(match) {
        const tpl = document.getElementById('match-details-template');
        const node = tpl.content.cloneNode(true);
        const modal = node.querySelector('.modal');
        const form = node.querySelector('.match-details-form');
        
        // Populate form with match data
        form['match-id'].value = match.id || '';
        form['sport-type'].value = match.sport_type || 'football';
        form['competition-type'].value = match.competition_type || 'liga';
        form['match-date'].value = match.date || '';
        form['match-time'].value = match.time || '';
        form['location'].value = match.location || '';
        form['referee'].value = match.referee || '';
        form['status'].value = match.status || 'planned';
        form['result'].value = match.result || '';
        form['notes'].value = match.notes || '';
        
        // Populate team selectors
        populateTeamSelectors(form);
        
        // Set team values
        if (match.team_a) form['team-a'].value = match.team_a;
        if (match.team_b) form['team-b'].value = match.team_b;
        
        // Setup event listeners
        form.querySelector('.cancel').addEventListener('click', () => modal.remove());
        form.querySelector('.save-match').addEventListener('click', () => saveMatch(modal, form));
        form.querySelector('.delete-match').addEventListener('click', () => deleteMatch(match.id, modal));
        
        document.body.appendChild(node);
      }
      
      /** Populate team selectors */
      function populateTeamSelectors(form) {
        const teamASelect = form['team-a'];
        const teamBSelect = form['team-b'];
        
        // Clear existing options
        teamASelect.innerHTML = '<option value="">Wybierz drużynę</option>';
        teamBSelect.innerHTML = '<option value="">Wybierz drużynę</option>';
        
        // Add team options
        const teams = Object.values(window._adminTeamsById || {});
        teams.forEach(team => {
          const teamId = team.team_id || team.id;
          const teamName = team.team_name || team.name;
          
          const optionA = document.createElement('option');
          optionA.value = teamId;
          optionA.textContent = teamName;
          teamASelect.appendChild(optionA);
          
          const optionB = document.createElement('option');
          optionB.value = teamId;
          optionB.textContent = teamName;
          teamBSelect.appendChild(optionB);
        });
      }
      
      /** Generate new match ID */
      function generateNewMatchId() {
        const allMatches = window._scheduleData || [];
        const existingIds = allMatches.map(m => parseInt(m.id.replace(/\D/g, ''))).filter(id => !isNaN(id));
        const maxId = existingIds.length > 0 ? Math.max(...existingIds) : 0;
        return `match_${maxId + 1}`;
      }
      
      /** Save match */
      async function saveMatch(modal, form) {
        // Validate form
        if (!form['match-date'].value || !form['team-a'].value || !form['team-b'].value) {
          showNotification('Proszę uzupełnić wymagane pola', 'error');
          return;
        }
        
        if (form['team-a'].value === form['team-b'].value) {
          showNotification('Drużyny muszą być różne', 'error');
          return;
        }
        
        const matchData = {
          id: form['match-id'].value,
          sport_type: form['sport-type'].value,
          competition_type: form['competition-type'].value,
          date: form['match-date'].value,
          time: form['match-time'].value,
          team_a: form['team-a'].value,
          team_b: form['team-b'].value,
          location: form['location'].value,
          referee: form['referee'].value,
          status: form['status'].value,
          result: form['result'].value,
          notes: form['notes'].value
        };
        
        // Get team names
        const teamA = window._adminTeamsById?.[matchData.team_a];
        const teamB = window._adminTeamsById?.[matchData.team_b];
        matchData.team_a_name = teamA?.team_name || teamA?.name || matchData.team_a;
        matchData.team_b_name = teamB?.team_name || teamB?.name || matchData.team_b;
        
        try {
          // Save to Google Sheets
          const sheetName = `matches_${matchData.sport_type}`;
          await saveMatchToSheet(sheetName, matchData);
          
          // Update local data
          const existingIndex = window._scheduleData.findIndex(m => m.id === matchData.id);
          if (existingIndex >= 0) {
            window._scheduleData[existingIndex] = matchData;
          } else {
            window._scheduleData.push(matchData);
          }
          
          // Refresh display
          filterAndRenderSchedule();
          renderCalendar();
          
          showNotification('Mecz zapisany pomyślnie', 'success');
          modal.remove();
          
        } catch (error) {
          console.error('Error saving match:', error);
          showNotification('Błąd podczas zapisu meczu', 'error');
        }
      }
      
      /** Save match to Google Sheets (uses POST updateRow / appendRow via Apps Script Web App) */
      async function saveMatchToSheet(sheetName, matchData) {
        try {
          // First, check if match already exists
          const existingData = await fetchCsv(sheetName);
          const dataArray = csvToArray(existingData);
          const headers = dataArray[0] || [];
          
          // Find if match already exists by match id
          const matchIdIndex = headers.findIndex(h => (h || '').toLowerCase().includes('match_id'));
          let existingRowIndex = -1;
          
          if (matchIdIndex !== -1) {
            for (let i = 1; i < dataArray.length; i++) {
              if (dataArray[i][matchIdIndex] === matchData.id) {
                existingRowIndex = i;
                break;
              }
            }
          }

          // Build values array (basketball special-case remains)
          let values;
          if (sheetName === 'matches_basketball' || sheetName === 'Basketball') {
            values = [
              matchData.id,
              matchData.competition_type || '',
              matchData.date || '',
              matchData.team_a || '',
              matchData.team_b || '',
              matchData.result ? matchData.result.split(':')[0] : '',
              matchData.result ? matchData.result.split(':')[1] : '',
              matchData.location || '',
              matchData.referee || '',
              matchData.time || '',
              matchData.status || '',
              matchData.notes || ''
            ];
          } else {
            values = [
              matchData.id || '',
              matchData.competition_type || '',
              matchData.date || '',
              matchData.team_a || '',
              matchData.team_b || '',
              matchData.result ? matchData.result.split(':')[0] : '',
              matchData.result ? matchData.result.split(':')[1] : '',
              matchData.location || '',
              matchData.referee || '',
              matchData.time || '',
              matchData.status || '',
              matchData.notes || ''
            ];
          }

          // Prepare payload depending on update or append
          let payload;
          if (existingRowIndex !== -1) {
            console.log(`Updating existing match ${matchData.id} at row ${existingRowIndex + 1}`);
            payload = {
              action: 'updateRow',
              sheetName: sheetName,
              rowIndex: existingRowIndex + 1, // Sheets are 1-indexed
              values: values
            };
          } else {
            console.log(`Appending new match ${matchData.id}`);
            payload = {
              action: 'appendRow',
              sheetName: sheetName,
              values: [values]
            };
          }

          // Use POST (no-cors) to call Apps Script Web App — safer for larger payloads
          try {
            await fetch(SCRIPT_URL, {
              method: 'POST',
              mode: 'no-cors',
              body: JSON.stringify(payload)
            });
          } catch (fetchErr) {
            // fetch with no-cors may still throw in some environments; log but continue
            console.warn('Fetch (no-cors) request error (this may be expected):', fetchErr);
          }

          // Refresh schedule data shortly after to pick up changes
          setTimeout(() => {
            loadScheduleData().catch(e => console.warn('loadScheduleData after save failed:', e));
          }, 1000);

          showNotification('Mecz zapisany (wysłano żądanie do arkusza)', 'success');
          return { success: true };
        } catch (error) {
          console.error('Error saving match to sheet:', error);
          showNotification('Błąd przy zapisywaniu meczu: ' + (error && error.message || error), 'error');
          throw error;
        }
      }
      
      /** Delete match */
      async function deleteMatch(matchId, modal) {
        if (!confirm('Czy na pewno chcesz usunąć ten mecz?')) {
          return;
        }
        
        try {
          // Remove from local data
          window._scheduleData = window._scheduleData.filter(m => m.id !== matchId);
          
          // Refresh display
          filterAndRenderSchedule();
          renderCalendar();
          
          showNotification('Mecz usunięty pomyślnie', 'success');
          
          if (modal) {
            modal.remove();
          }
          
        } catch (error) {
          console.error('Error deleting match:', error);
          showNotification('Błąd podczas usuwania meczu', 'error');
        }
      }
      
      /* Settings panel initialization removed */
      
      /* loadTeamsDataForSettings removed (settings UI deleted) */
      
      /** Load teams data if not already available */
      async function loadTeamsDataIfNeeded() {
        try {
          console.log('Attempting to load teams data...');
          
          // Use existing CSV loading mechanism
          const csvUrl = `https://docs.google.com/spreadsheets/d/${SPREADSHEET_ID}/gviz/tq?tqx=out:csv&sheet=${SHEETS.TEAMS}`;
          const response = await fetch(csvUrl);
          const csvText = await response.text();
          
          // Parse CSV data
          const data = parseCSV(csvText);
          if (data && data.length > 1) {
            renderTeamsFromSheet(data);
            const teamsData = Object.values(window._adminTeamsById || {});
            if (teamsData.length > 0) {
              updateSettingsBasedOnTeamsCount(teamsData.length);
              window._teamsCount = teamsData.length;
            }
          }
        } catch (error) {
          console.error('Failed to load teams data:', error);
        }
      }
      
      /** Update settings fields based on teams count */
      function updateSettingsBasedOnTeamsCount(teamsCount) {
        console.log(`Updating settings for ${teamsCount} teams`);
        
        // Update football settings
        updateFootballTeamFields(teamsCount);
        
        // Update basketball settings
        updateBasketballTeamFields(teamsCount);
        
        // Update volleyball settings
        updateVolleyballTeamFields(teamsCount);
      }
      
      /** Update football team-related fields */
      function updateFootballTeamFields(teamsCount) {
        // Update teams per group field
        const teamsPerGroup = document.getElementById('football-teams-per-group');
        if (teamsPerGroup) {
          teamsPerGroup.max = teamsCount;
          teamsPerGroup.value = Math.min(teamsPerGroup.value, teamsCount);
        }
        
        // Update teams advance field
        const teamsAdvance = document.getElementById('football-teams-advance');
        if (teamsAdvance) {
          teamsAdvance.max = teamsCount;
          teamsAdvance.value = Math.min(teamsAdvance.value, teamsCount);
        }
        
        // Update cup teams dropdown
        const cupTeams = document.getElementById('football-cup-teams');
        if (cupTeams) {
          updateCupTeamsDropdown(cupTeams, teamsCount);
        }
      }
      
      /** Update basketball team-related fields */
      function updateBasketballTeamFields(teamsCount) {
        // Update teams per group field
        const teamsPerGroup = document.getElementById('basketball-teams-per-group');
        if (teamsPerGroup) {
          teamsPerGroup.max = teamsCount;
          teamsPerGroup.value = Math.min(teamsPerGroup.value, teamsCount);
        }
        
        // Update teams advance field
        const teamsAdvance = document.getElementById('basketball-teams-advance');
        if (teamsAdvance) {
          teamsAdvance.max = teamsCount;
          teamsAdvance.value = Math.min(teamsAdvance.value, teamsCount);
        }
        
        // Update cup teams dropdown
        const cupTeams = document.getElementById('basketball-cup-teams');
        if (cupTeams) {
          updateCupTeamsDropdown(cupTeams, teamsCount);
        }
      }
      
      /** Update volleyball team-related fields */
      function updateVolleyballTeamFields(teamsCount) {
        // Update teams per group field
        const teamsPerGroup = document.getElementById('volleyball-teams-per-group');
        if (teamsPerGroup) {
          teamsPerGroup.max = teamsCount;
          teamsPerGroup.value = Math.min(teamsPerGroup.value, teamsCount);
        }
        
        // Update teams advance field
        const teamsAdvance = document.getElementById('volleyball-teams-advance');
        if (teamsAdvance) {
          teamsAdvance.max = teamsCount;
          teamsAdvance.value = Math.min(teamsAdvance.value, teamsCount);
        }
        
        // Update cup teams dropdown
        const cupTeams = document.getElementById('volleyball-cup-teams');
        if (cupTeams) {
          updateCupTeamsDropdown(cupTeams, teamsCount);
        }
      }
      
      /** Update cup teams dropdown based on available teams */
      function updateCupTeamsDropdown(dropdown, teamsCount) {
        // Clear existing options
        dropdown.innerHTML = '';
        
        // Add valid options based on teams count
        const validOptions = [2, 4, 8, 16, 32].filter(num => num <= teamsCount);
        
        if (validOptions.length === 0) {
          // If no valid options, add current teams count if it's a power of 2
          if (teamsCount > 0 && (teamsCount & (teamsCount - 1)) === 0) {
            const option = document.createElement('option');
            option.value = teamsCount;
            option.textContent = `${teamsCount} drużyny`;
            dropdown.appendChild(option);
          } else {
            const option = document.createElement('option');
            option.value = teamsCount;
            option.textContent = `${teamsCount} drużyn (niestandardowe)`;
            dropdown.appendChild(option);
          }
        } else {
          validOptions.forEach(num => {
            const option = document.createElement('option');
            option.value = num;
            option.textContent = num === 2 ? '2 drużyny' : `${num} drużyn`;
            dropdown.appendChild(option);
          });
        }
        
        // Set default to the highest valid option
        if (validOptions.length > 0) {
          dropdown.value = Math.max(...validOptions);
        }
      }
      
      /* loadSettings and applySettings removed with settings UI */
      
      /* saveSettings removed (settings UI deleted) */
      
      /* resetSettings removed (settings UI deleted) */

      /* clearSettingsForm removed */

      /* toggleCompetitionSettings removed */

      /* Settings helpers removed (toggle handlers, sync functions) */
      
      </script>

      <!-- PLANER ROZGRYWEK: Split-screen, Drag&Drop, Data, Walidacja -->
      <script>
      // Ustawienia siatki
      const PLANNER_START_HOUR = 7;
      const PLANNER_END_HOUR = 17;
      const PLANNER_STEP_MIN = 30;
      const PLANNER_PITCHES = ["Boisko 1", "Boisko 2", "Boisko 3"];
      const PLANNER_DISCIPLINE_COLORS = {
        football: '#2196f3',
        basketball: '#ff9800',
        volleyball: '#4caf50',
        block: '#e53935'
      };

      let plannerDate = new Date();
      let plannerAssignments = {}; // { 'YYYY-MM-DD': [ { ...match, pitch, time, duration, type: 'match'|'block' } ] }
      let plannerUnassigned = [];

      function formatPlannerDate(date) {
        return date.toLocaleDateString('pl-PL', { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' });
      }
      function getPlannerDateStr(date) {
        return date.toISOString().split('T')[0];
      }

      function showPlannerPanel() {
        document.getElementById('teams-panel').style.display = 'none';
        document.getElementById('matches-panel').style.display = 'none';
        document.getElementById('schedule-panel').style.display = 'none';
        document.getElementById('planner-panel').style.display = 'block';
        
        // Załaduj zaplanowane mecze ze spisu danych
        updatePlannerMatchesFromDb();
        
        renderPlannerHeader();
        renderPlannerGrid();
        renderUnassignedMatches();
      }

      function renderPlannerHeader() {
        const label = document.getElementById('planner-date-label');
        label.textContent = formatPlannerDate(plannerDate);
        const picker = document.getElementById('planner-date-picker');
        picker.value = getPlannerDateStr(plannerDate);
      }

      function renderPlannerGrid() {
        const grid = document.getElementById('planner-grid');
        grid.innerHTML = '';
        // Header
        const header = document.createElement('div');
        header.className = 'planner-grid-header';
        header.innerHTML = '<div class="planner-grid-timecol"></div>' + PLANNER_PITCHES.map(p => `<div class="planner-grid-pitch">${p}</div>`).join('');
        grid.appendChild(header);
        // Godziny
        for (let h = PLANNER_START_HOUR; h < PLANNER_END_HOUR; h++) {
          for (let m = 0; m < 60; m += PLANNER_STEP_MIN) {
            const row = document.createElement('div');
            row.className = 'planner-grid-row';
            const timeLabel = document.createElement('div');
            timeLabel.className = 'planner-grid-timecol';
            timeLabel.textContent = `${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}`;
            row.appendChild(timeLabel);
            for (let p = 0; p < PLANNER_PITCHES.length; p++) {
              const cell = document.createElement('div');
              cell.className = 'planner-grid-cell';
              cell.dataset.pitch = p;
              cell.dataset.time = `${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}`;
              cell.dataset.hour = h;
              cell.dataset.minute = m;
              cell.ondragover = e => plannerCellDragOver(e, cell);
              cell.ondrop = e => plannerCellDrop(e, cell);
              cell.ondragenter = e => plannerCellDragEnter(e, cell);
              cell.ondragleave = e => plannerCellDragLeave(e, cell);
              // Render przypisane mecze/blokady
              const dateStr = getPlannerDateStr(plannerDate);
              const slotItems = (plannerAssignments[dateStr]||[]).filter(item => item.pitch == p && item.time === cell.dataset.time);
              slotItems.forEach(item => {
                const card = createPlannerMatchCard(item, true);
                cell.appendChild(card);
              });
              row.appendChild(cell);
            }
            grid.appendChild(row);
          }
        }
      }

      function renderUnassignedMatches() {
        const list = document.getElementById('unassigned-matches-list');
        list.innerHTML = '';
        
        if (plannerUnassigned.length === 0) {
          const emptyMsg = document.createElement('div');
          emptyMsg.style.cssText = 'color: #999; text-align: center; padding: 40px 20px; font-style: italic;';
          emptyMsg.textContent = 'Wszystkie mecze przypisane!';
          list.appendChild(emptyMsg);
        }
        
        plannerUnassigned.forEach(match => {
          const card = createPlannerMatchCard(match, false);
          list.appendChild(card);
        });
        
        // Dragowanie kafelka blokady czasu
        const blockTile = document.getElementById('block-time-tile');
        blockTile.ondragstart = e => {
          e.dataTransfer.setData('text/plain', JSON.stringify({ type: 'block', duration: 30 }));
        };
      }

      function createPlannerMatchCard(match, compact) {
        const card = document.createElement('div');
        card.className = 'planner-match-card';
        card.draggable = true;
        card.dataset.id = match.id || '';
        card.dataset.type = match.type || 'match';
        card.dataset.duration = match.duration || 30;
        card.dataset.pitch = match.pitch !== undefined ? match.pitch : '';
        card.dataset.time = match.time || '';
        card.dataset.sport = match.sport_type || match.sport || '';
        card.style.borderLeft = `6px solid ${PLANNER_DISCIPLINE_COLORS[match.sport_type||match.sport||'block']}`;
        card.ondragstart = e => {
          e.dataTransfer.setData('text/plain', JSON.stringify(match));
        };
        card.innerHTML = `
          <div class="planner-match-main">
            <span class="planner-match-icon">${getSportIcon(match.sport_type||match.sport)}</span>
            <span class="planner-match-teams">${escapeHtml(match.team_a_name||'')}${match.team_b_name ? ' vs ' + escapeHtml(match.team_b_name) : ''}</span>
          </div>
          <div class="planner-match-meta">
            <span class="planner-match-duration">${match.duration||30} min</span>
          </div>
        `;
        if (compact) card.classList.add('compact');
        return card;
      }

      function getSportIcon(sport) {
        if (sport === 'football') return '⚽';
        if (sport === 'basketball') return '🏀';
        if (sport === 'volleyball') return '🏐';
        if (sport === 'block') return '⛔';
        return '❓';
      }

      // Drag & Drop obsługa
      function plannerCellDragOver(e, cell) {
        e.preventDefault();
        cell.classList.add('drag-over');
      }
      function plannerCellDragEnter(e, cell) {
        cell.classList.add('drag-over');
      }
      function plannerCellDragLeave(e, cell) {
        cell.classList.remove('drag-over');
      }

      // Update match date/time in Google Sheets
      async function updateMatchInSheet(match, newDate, newTime, sport) {
        try {
          // Map sport type to sheet name
          const sportSheetMap = {
            'football': 'matches_football',
            'basketball': 'matches_basketball',
            'volleyball': 'matches_volleyball'
          };
          const sheetName = sportSheetMap[sport] || `matches_${sport}`;
          
          // Fetch the sheet to find the match row
          const existingData = await fetchCsv(sheetName);
          const dataArray = csvToArray(existingData);
          const headers = dataArray[0];
          
          // Find match ID column
          const matchIdIndex = headers.findIndex(h => h.toLowerCase().includes('match_id') || h.toLowerCase().includes('id'));
          const dateIndex = headers.findIndex(h => h.toLowerCase().includes('date') || h.toLowerCase().includes('data'));
          const timeIndex = headers.findIndex(h => h.toLowerCase().includes('time') || h.toLowerCase().includes('czas'));
          
          if (matchIdIndex === -1) {
            console.error('Match ID column not found');
            return;
          }
          
          // Find the row with this match
          let rowIndex = -1;
          for (let i = 1; i < dataArray.length; i++) {
            if (dataArray[i][matchIdIndex] === match.id) {
              rowIndex = i;
              break;
            }
          }
          
          if (rowIndex === -1) {
            console.error(`Match ${match.id} not found in ${sheetName} sheet`);
            return;
          }
          
          // Prepare updated row
          const updatedRow = dataArray[rowIndex].slice();
          if (dateIndex !== -1) updatedRow[dateIndex] = newDate;
          if (timeIndex !== -1) updatedRow[timeIndex] = newTime;
          
          // Update the row in Google Sheets using new API
          const result = await callGoogleAppsScriptAPI('updateRow', {
            spreadsheetId: SPREADSHEET_ID,
            sheetName: sheetName,
            rowIndex: rowIndex + 1, // Google Sheets is 1-indexed
            values: [updatedRow]
          });
          
          if (!result.success) {
            throw new Error(result.error || 'Update failed');
          }
          
          console.log(`Successfully updated ${match.id} with date=${newDate}, time=${newTime} in ${sheetName} sheet`);
          return result;
          
        } catch (error) {
          console.error('Error updating match in sheet:', error);
          showNotification('Błąd przy aktualizacji meczu: ' + error.message, 'error');
        }
      }

      // Wywołanie JSONP do Google Apps Script — bezpieczniejsza wersja przenoszenia meczu
      async function handleMatchMove(matchId, sport, date, time, pitchIndex) {
        // pitchIndex otrzymujemy jako 0, 1, 2...
        // Zapisujemy go jako liczbę (lub prosty string '0'), aby zachować spójność z bazą
        const pitchValue = parseInt(pitchIndex, 10);

        const url = `${SCRIPT_URL}?action=updateMatchAssignment&matchId=${encodeURIComponent(matchId)}&sport=${encodeURIComponent(sport)}&date=${encodeURIComponent(date)}&time=${encodeURIComponent(time)}&pitch=${encodeURIComponent(pitchValue)}`;

        return new Promise((resolve, reject) => {
          const script = document.createElement('script');
          const callbackName = 'jsonp_callback_' + Math.round(100000 * Math.random());

          window[callbackName] = function(data) {
            try {
              delete window[callbackName];
              document.body.removeChild(script);
              if (data && data.success) {
                console.log('Zaktualizowano mecz:', data.message || data);
                resolve(data);
              } else {
                alert('Błąd zapisu: ' + (data && data.error || 'nieznany błąd'));
                reject(data && data.error || new Error('Update failed'));
              }
            } catch (err) {
              try { delete window[callbackName]; } catch(e){}
              try { document.body.removeChild(script); } catch(e){}
              reject(err);
            }
          };

          script.src = `${url}&callback=${callbackName}`;
          script.onerror = () => {
            try { delete window[callbackName]; } catch (e) { }
            try { document.body.removeChild(script); } catch (e) { }
            reject(new Error('Network error loading script'));
          };
          document.body.appendChild(script);
        });
      }

      // Backward-compatible global handler (opcjonalny - zachowuje zgodność ze starej implementacji)
      window.onUpdateResponse = function(response) {
        if (response && response.success) {
          console.log("✅ Arkusz zaktualizowany!", response);
        } else {
          console.warn("Błąd aktualizacji arkusza:", response);
          showNotification("Błąd aktualizacji arkusza: " + (response && response.error || 'unknown'), 'error');
        }
      };

      function plannerCellDrop(e, cell) {
        e.preventDefault();
        cell.classList.remove('drag-over');
        let data;
        try { data = JSON.parse(e.dataTransfer.getData('text/plain')); } catch { return; }
        const dateStr = getPlannerDateStr(plannerDate);
        const pitch = parseInt(cell.dataset.pitch);
        const time = cell.dataset.time;
        // Walidacja kolizji
        if (data.type === 'match') {
          if (hasTeamConflict(dateStr, time, pitch, data)) {
            cell.classList.add('conflict');
            setTimeout(()=>cell.classList.remove('conflict'), 1200);
            showNotification('Kolizja: drużyna już gra w tym czasie!', 'error');
            return;
          }
        }
        // Przypisz do slotu
        if (!plannerAssignments[dateStr]) plannerAssignments[dateStr] = [];
        // Jeśli mecz już był na siatce, przesuń go
        if (data.type === 'match') {
          // Usuń z poprzedniego slotu jeśli był
          for (const d in plannerAssignments) {
            plannerAssignments[d] = plannerAssignments[d].filter(m => m.id !== data.id);
          }
          // Usuń z puli nieprzypisanych
          plannerUnassigned = plannerUnassigned.filter(m => m.id !== data.id);
          plannerAssignments[dateStr].push({ ...data, pitch, time });
          
          // Automatycznie zaktualizuj datę i czas w Google Sheets (przez Apps Script JSONP)
          showNotification(`Aktualizuję mecz ${data.id} w kalendarzu...`, 'info');
          handleMatchMove(data.id, data.sport_type || data.sport, dateStr, time, pitch).then(() => {
            console.log(`Mecz ${data.id} zaktualizowany (via Apps Script)`);
            // Reload match data to ensure consistency with Google Sheets
            return loadScheduleData();
          }).then(() => {
            // Refresh the unassigned matches to show updated data
            renderUnassignedMatches();
            showNotification(`Mecz ${data.id} został przeniesiony`, 'success');
          }).catch(err => {
            console.error(`Błąd przy aktualizacji meczu ${data.id}:`, err);
            showNotification(`Błąd: nie udało się zaktualizować meczu w Google Sheets: ${err && err.error || err && err.message || err}`, 'error');
          });
        } else if (data.type === 'block') {
          plannerAssignments[dateStr].push({ type: 'block', pitch, time, duration: 30 });
        }
        renderPlannerGrid();
        renderUnassignedMatches();
      }

      function hasTeamConflict(dateStr, time, pitch, match) {
        // Sprawdź czy któraś z drużyn gra już w tym czasie na innym boisku
        const items = (plannerAssignments[dateStr]||[]);
        for (const item of items) {
          if (item.type !== 'match') continue;
          if (item.time === time && (item.team_a_id === match.team_a_id || item.team_b_id === match.team_a_id || item.team_a_id === match.team_b_id || item.team_b_id === match.team_b_id)) {
            return true;
          }
        }
        return false;
      }

      // Zmiana daty
      document.addEventListener('DOMContentLoaded', () => {
        const prevBtn = document.getElementById('planner-prev-day');
        const nextBtn = document.getElementById('planner-next-day');
        const picker = document.getElementById('planner-date-picker');
        if (prevBtn) prevBtn.addEventListener('click', () => {
          plannerDate.setDate(plannerDate.getDate() - 1);
          renderPlannerHeader();
          renderPlannerGrid();
        });
        if (nextBtn) nextBtn.addEventListener('click', () => {
          plannerDate.setDate(plannerDate.getDate() + 1);
          renderPlannerHeader();
          renderPlannerGrid();
        });
        if (picker) picker.addEventListener('change', (e) => {
          plannerDate = new Date(e.target.value);
          renderPlannerHeader();
          renderPlannerGrid();
        });
      });

      // Integracja z showTab
      const origShowTab = window.showTab;
      window.showTab = function(name) {
        if (name === 'planner') {
          showPlannerPanel();
        } else if (typeof origShowTab === 'function') {
          origShowTab(name);
        }
      };

      // Inicjalizacja danych do planera: dynamiczne ładowanie meczów z bazy
      function updatePlannerMatchesFromDb() {
        // Pobierz mecze z window._adminMatches (wszystkie dyscypliny)
        const unassignedMatches = [];
        plannerAssignments = {}; // Reset przypisań
        
        if (window._adminMatches) {
          ['football','basketball','volleyball'].forEach(sport => {
            const sportMatches = window._adminMatches[sport] || [];
            
            sportMatches.forEach((m, idx) => {
              const matchObj = {
                id: m.match_id || m.id,
                team_a_name: m.team_a_name || m.team_a || '',
                team_b_name: m.team_b_name || m.team_b || '',
                team_a_id: m.team_a_id || m.team_a || '',
                team_b_id: m.team_b_id || m.team_b || '',
                sport_type: sport,
                duration: 30,
                type: 'match',
                date: m.date || m.data || '',
                time: m.time || m.czas || '07:00' // Domyślnie 07:00 jeśli brak czasu
              };
              
              // Jeśli mecz ma datę, przypisz go do odpowiedniego slotu (czas już ma domyślny)
              if (matchObj.date) {
                const dateStr = matchObj.date;
                if (!plannerAssignments[dateStr]) {
                  plannerAssignments[dateStr] = [];
                }
                // Spróbuj wziąć boisko z danych, jeśli nie ma, domyślnie 0
                let pitch = 0;
                if (m.pitch !== undefined && m.pitch !== null && m.pitch !== '') {
                  pitch = parseInt(m.pitch);
                  if (isNaN(pitch)) pitch = 0;
                } else if (m.boisko) {
                  pitch = parseInt(m.boisko);
                  if (isNaN(pitch)) pitch = 0;
                }
                
                plannerAssignments[dateStr].push({
                  ...matchObj,
                  pitch: pitch
                });
              } else {
                // Mecz bez daty - dodaj do nieprzypisanych
                unassignedMatches.push(matchObj);
              }
            });
          });
        }
        
        plannerUnassigned = unassignedMatches;
        renderUnassignedMatches && renderUnassignedMatches();
        renderPlannerGrid && renderPlannerGrid();
      }
      // Po załadowaniu danych z bazy (loadAdminData), wywołaj updatePlannerMatchesFromDb
      document.addEventListener('DOMContentLoaded', () => {
        if (window._adminMatches) updatePlannerMatchesFromDb();
      });
      // Podmień w loadAdminData (po window._adminMatches = ...) dodaj updatePlannerMatchesFromDb();
      const origLoadAdminData = window.loadAdminData;
      window.loadAdminData = async function(...args) {
        const result = await origLoadAdminData.apply(this, args);
        updatePlannerMatchesFromDb();
        return result;
      };

      // --- SYNCHRONIZACJA WIELOUŻYTKOWNIKOWA ---
      let autoRefreshInterval;

      function startAutoRefresh() {
        // Czyścimy poprzedni interwał, jeśli istniał
        if (autoRefreshInterval) clearInterval(autoRefreshInterval);
        
        autoRefreshInterval = setInterval(async () => {
          console.log('Automatyczne odświeżanie danych...');
          try {
            // Pobieramy świeże dane z CSV (Google Sheets)
            await loadScheduleData();
            // Jeśli mamy otwarty panel admina, odświeżamy też jego widoki
            if (typeof loadAdminData === 'function') {
              await loadAdminData();
            }
            console.log('Dane zsynchronizowane.');
          } catch (e) {
            console.warn('Auto-refresh nieudany (prawdopodobnie brak sieci):', e);
          }
        }, 30000); // 30 sekund - optymalny czas dla Google Sheets
      }

      // Uruchom przy starcie
      document.addEventListener('DOMContentLoaded', startAutoRefresh);

      // Opcjonalnie: zatrzymaj odświeżanie, gdy karta jest nieaktywna (oszczędność transferu)
      document.addEventListener('visibilitychange', () => {
        if (document.hidden) {
          clearInterval(autoRefreshInterval);
        } else {
          startAutoRefresh();
        }
      });

      </script>
  </section>
</body>
</html>